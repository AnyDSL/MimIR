fn range_xy<L>(mut l : L,
                  xn : int, yn : int,
                  body : fn(L, int, int) -> L) -> L
{
    for (let mut y = 0; y < yn; ++y)
        for (let mut x = 0; x < xn; ++x)
            l = body(l, x, y);

    return l;
}


fn initially<G,T,R>(g : G, xn: int, yn : int, make_strand : fn(G) -> T, write_result : fn(int, int, G, R) -> G, update : fn(G, T, int, int, /*loop*/ fn(T), /*stabilize*/ fn(R), /*die*/ fn())) -> G {
    return range_xy(g, xn, yn, |g : G, x : int, y : int, ret : fn(G)| { 
        fn loop(strand : T) {
            update(g, strand, x, y, 
                loop, 
                stab,
                die); 
        }

        fn stab(res : R) { ret(write_result(x, y, g, res)); }

        fn die() { ret(g); }

        loop(make_strand(g));
    });
}

fn main(j : int) -> int64 {
    fn update(g : int64, t : int16, xn : int, yn : int, loop : fn(int16), stabilize : fn(int16), die : fn()) {
        if (xn + yn < 42)
            die();
        if (t == 23s)
            stabilize(t);
        loop(t + 1s);
    }

    fn make_strand(g : int64) -> int16 {
        return 24s;
    }

    fn write_result(x : int, y : int, g : int64, r : int16) -> int64 {
        return 25l;
    }

    let mut g = 26l;

    return initially(g, 100, 200, make_strand, write_result, update);
}
