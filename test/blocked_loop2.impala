fn range_step(a: int, b: int, step: int, yield : fn(int, fn())) -> void {
    let mut i: int = a;
    while (i < b) {
        let old = i;
        i += step;
        yield(old, || { continue; });
    }
}

fn get_block_size(i : int) -> int {
    if (i == 0)
        return 4096;
    else if (i == 1)
        return 2048;
    else if (i == 2)
        return 1024;
    else if (i == 3)
        return 256;
    else
        return 0;
}

fn blocked_loop(n: int, length: int, bodyfn: fn(int, fn(int))) -> int {
    fn blocked_iter(cur_level: int, i: int, N: int) -> int {
        let block_size = get_block_size(cur_level);
        if (block_size <= 0)
            return bodyfn(i);
        let mut res = 0;

        $range_step(i, N, block_size, |i: int| -> void {
            res += @blocked_iter(cur_level + 1, i, block_size);
        });
        return res;
    }

    return blocked_iter(n, 0, length);
}

fn main(n: int) -> int {
    return @blocked_loop(n, |i: int| -> int { return i+7; });
}
