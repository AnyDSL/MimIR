extern nvvm(int, (int, int, int), (int, int, int), fn() -> void) -> void;
extern array(int, int, int) -> [float];
extern async(fn() -> void) -> int;

fn iteration(width : int, height : int, img : [float], body : fn(int, int, [float]) -> void) -> void {
    // slice memory
    let mut cpu_slice1 = slice(img, 0,       0, width/2, height);
    let mut cpu_slice2 = slice(img, width/2, 0, width/2, height);
    let mut gpu_img1 = map<GPU1>(cpu_slice1);
    let mut gpu_img2 = map<GPU2>(cpu_slice2);

    let dim = (width/2, height, 1);
    let block = (32, 4, 1);

    let handle1 = async(|| -> void {
        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body(tid_x, tid_y, gpu_img1);
        });
    });

    let handle2 = async(|| -> void {
        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body(tid_x, tid_y, gpu_img2);
        });
    });

    let gpu_mems = [[float] * 2];
    gpu_mems[0] = gpu_img1;
    gpu_mems[1] = gpu_img2;
    let num_devices = 2;
    let handles = [float * 2];
    iterate(0, num_devices+1, |i : int| -> void {
        body(tid_x, tid_y + i * nvvm_read_ptx_sreg_ntid_y());
        handles[i] = async(|| -> void {
            nvvm(1, dim, block, || -> void {
                let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
                let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

                body(tid_x, tid_y, gpu_mems[i]);
            });
        });
    });

    // synchronize explicitly on handles
    synchronize(handle1);
    synchronize(handle2);
    // alternatively synchronize on GPU devices
    synchronize(GPU1);
    synchronize(GPU2);
}


fn iteration(width : int, height : int, img : [float], body : fn(int, int, [float], [float]) -> void) -> void {
    // slice memory
    let mut cpu_slice1 = slice(img, 0,       0, width/2, height);
    let mut cpu_slice2 = slice(img, width/2, 0, width/2, height);
    let mut gpu_img1 = map<GPU1>(cpu_slice1);
    let mut gpu_img2 = map<GPU2>(cpu_slice2);

    let dim = (width/2, height, 1);
    let block = (32, 4, 1);

    let handle1 = async(|| -> void {
        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            let mut sm = sm_array(block[0], block[1]);
            let sm_x = nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let sm_y = nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            // GPU execution with dedicated scratchpad memory
            let offset_x = 0, offset_y = 0;
            sm = map<SM>(gpu_img1, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);
            // execution with scratchpad memory mapped to global memory
            sm = map<PROXY>(gpu_img1, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);

            body(tid_x, tid_y, gpu_img1, sm);
        });
    });

    let handle2 = async(|| -> void {
        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            let mut sm = sm_array(block[0], block[1]);
            let sm_x = nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let sm_y = nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            // GPU execution with dedicated scratchpad memory
            let offset_x = 0, offset_y = 0;
            sm = map<SM>(gpu_img2, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);
            // execution with scratchpad memory mapped to global memory
            sm = map<PROXY>(gpu_img2, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);

            body(tid_x, tid_y, gpu_img2, sm);
        });
    });

    // synchronize explicitly on handles
    synchronize(handle1);
    synchronize(handle2);
    // alternatively synchronize on GPU devices
    synchronize(GPU1);
    synchronize(GPU2);
}


fn main() -> [float] {
    let width   = 2048;
    let height  = 2048;
    let mut img = array(4, width, height);

    let stencil : [float * 3] = [ 0.25f, 0.50f, 0.25f ];

    convolution_separable(img, stencil, stencil);

    return img;
}


// explicit variant
fn convolution_separable(img: [float],
                         stencil_row: [float * 3 * 3],
                         stencil_col: [float * 3 * 3]) -> [float] {
    // temporary memory
    let img_gpu : [float] = map<GPU>(img);
    let tmp_gpu : [float] = array<GPU>(img.width(), img.height());

    // constant memory for stencil
    let stencil_row_gpu : [float * 3 * 3] = map<CM>(stencil_row);
    let stencil_col_gpu : [float * 3 * 3] = map<CM>(stencil_col);

    for gid_x, gid_y in range(tmp_gpu) run on GPU {
        // thread index
        let tid_x = get_thread_idx(0);
        let tid_y = get_thread_idx(1);

        // shared memory for data staging
        let mut sdata : [float, float] = array<SM>(get_blocking(1), get_blocking(2));

        // load data to shared memory
        sdata[get_thread_idx(1), get_thread_idx(0)] = img_gpu[gid_x, gid_y];

        // synchronize
        barrier(SM);

        // apply stencil
        tmp_gpu[gid_x, gid_y] = @convolve(sdata, stencil_row_gpu);
    }

    for gid_x, gid_y in range(img_gpu) run on GPU {
        // thread index
        let tid_x = get_thread_idx(0);
        let tid_y = get_thread_idx(1);

        // shared memory for data staging
        let mut sdata : [float, float] = array<SM>(get_blocking(1), get_blocking(2));

        // load data to shared memory
        sdata[get_thread_idx(1), get_thread_idx(0)] = tmp_gpu[gid_x, gid_y];

        // synchronize
        barrier(SM);

        // apply stencil
        img_gpu[gid_x, gid_y] = @convolve(sdata, stencil_col_gpu);
    }

    // map GPU to CPU memory using map<CPU>()
    img = map(img_gpu);
}


// implicit variant
fn convolution_separable(img: [float],
                         stencil_row: [float * 3 * 3],
                         stencil_col: [float * 3 * 3]) -> [float] {
    let tmp : [float] = array(img.width(), img.height());

    for gid_x, gid_y in range(tmp) {
        // thread index
        let tid_x = get_thread_idx(0);
        let tid_y = get_thread_idx(1);

        // shared memory for data staging
        let mut sdata : [float, float] = array(get_blocking(1), get_blocking(2));

        // load data to shared memory
        sdata[get_thread_idx(1), get_thread_idx(0)] = img[gid_x, gid_y];

        // synchronize
        barrier();

        // apply stencil
        tmp[gid_x, gid_y] = @convolve(sdata, stencil_row);
    }

    for gid_x, gid_y in range(img) {
        // thread index
        let tid_x = get_thread_idx(0);
        let tid_y = get_thread_idx(1);

        // shared memory for data staging
        let mut sdata : [float, float] = array(get_blocking(1), get_blocking(2));

        // load data to shared memory
        sdata[get_thread_idx(1), get_thread_idx(0)] = tmp[gid_x, gid_y];

        // synchronize
        barrier();

        // apply stencil
        img[gid_x, gid_y] = @convolve(sdata, stencil_col);
    }
}

