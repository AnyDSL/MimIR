// current mapping: arrays are implicitely mapped to GPU
iteration(width, height, |x : int, y : int| -> void {
    out[y*width + x] = @apply_stencil(range, stencil, x, y, arr, width);
});

// proposed mapping: mapped array is passed as parameter
iteration_mapped(width, height, |x : int, y : int, arr : [float]| -> void {
    out[y*width + x] = @apply_stencil(range, stencil, x, y, arr, width);
});

// proposed mapping: mapped array is passed as parameter, using shared
// memory
iteration_mapped_smem(width, height,
    |x : int, y : int, arr : [float], smem : [float]| -> void {
        out[y*width + x] = @apply_stencil(range, stencil, x, y, arr, width);
    }
    |x : int, y : int, arr : [float], smem : [float]| -> void {
        out[y*width + x] = @apply_stencil(range, stencil, x, y, arr, width);
    }
);

fn iteration(width : int, height : int, body : fn(int, int) -> void) -> void {
    let dim = (width, height, 1);
    let block = (32, 4, 1);

    opencl(1, dim, block, || -> void {
        let tid_x = int64_to_int32(get_global_id(0));
        let tid_y = int64_to_int32(get_global_id(1));

        body(tid_x, tid_y);
    });
}


fn iteration_mapped(width : int, height : int, img : [float], body : fn(int, int, [float]) -> void) -> void {
    let dim = (width, height/2, 1);
    let block = (32, 4, 1);

    // explicit verstion
    let mut cl_mem = map<CPU, Global>(img);
    let mut s1 = slice(cl_img, 0, 0,        width, height/2);
    let mut s2 = slice(cl_img, 0, height/2, width, height/2);
    let mut g1 = map<GPU1, Global>(s1);
    let mut g2 = map<GPU2, Global>(s2);

    // skip map to cl mem
    let mut s1 = slice(img, 0, 0,        width, height/2);
    let mut s2 = slice(img, 0, height/2, width, height/2);
    let mut g1 = map<GPU1, Global>(s1);
    let mut g2 = map<GPU2, Global>(s2);

    // skip slicing
    let mut g1 = map_region<GPU1, Global>(img, (0, 0),        (width, height/2));
    let mut g2 = map_region<GPU2, Global>(img, (0, height/2), (width, height/2));


    let mut g = [ g1, g2 ];
    let mut h = [int * 2];
    
    @iterate(0, 2+1, |i : int| -> void {
        h[i] = opencl(i+1, dim, block, || -> void {
            let tid_x = int64_to_int32(get_global_id(0));
            let tid_y = int64_to_int32(get_global_id(1));

            body(tid_x, tid_y, g[i]);
        });
    });

    synchronize(h[0]);
    synchronize(h[1]);
    synchronize(GPU1);
    synchronize(GPU2);
}

fn iteration_mapped_smem(width : int, height : int, img : [float], body : fn(int, int, [float], [float]) -> void) -> void {
    let dim = (width, height/2, 1);
    let block = (32, 4, 1);

    // skip slicing
    let mut g1 = map_region<GPU1, Global>(img, (0, 0),        (width, height/2));
    let mut g2 = map_region<GPU2, Global>(img, (0, height/2), (width, height/2));

    let mut g = [ g1, g2 ];
    let mut h = [int * 2];

    
    @iterate(0, 2+1, |i : int| -> void {
        h[i] = opencl(i+1, dim, block, || -> void {
            let tid_x = int64_to_int32(get_global_id(0));
            let tid_y = int64_to_int32(get_global_id(1));

            // block size plus apron for 3x3 stencil
            let mut sm = sm_array(block[0] + 2, block[1] + 2);

            // load data to shared memory
            let sm_x = blockDim.x * blockIdx.x;
            let sm_y = blockDim.y * blockIdx.y;

            // GPU execution with dedicated scratchpad memory
            let mut sm = map<GPUX, Shared>(gpu_img, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);

            // execution with scratchpad memory mapped to global memory
            let mut sm = map<GPUX, Proxy >(gpu_img, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);

            out_view = map<GPUX, Proxy>(out, sm_x, sm_y, block[0], block[1]);

            barrier(sm);

            body(get_local_id(0), get_local_id(1), width, arr, out_view) {
                let mut sum = 0.0f;
                let half_range = range / 2;
                iterate(-half_range, half_range+1, |j : int| -> void {
                    iterate(-half_range, half_range+1, |i : int| -> void {
                        let stencil_index = i + half_range + ((j + half_range) * range);
                        let stencil_val = stencil[stencil_index];
                        sum += arr[x + i][y + j] * stencil_val;
                    });
                });
                out[y*width + x] = sum;
            }

            // higher-order version
            let out_fun = |val: float, i: int| -> void {
                out[tid_x + i][tid_y] = val;
            };
            body(get_local_id(0), get_local_id(1), width, arr, out_fun) {
                let mut sum = 0.0f;
                let half_range = range / 2;
                iterate(-half_range, half_range+1, |j : int| -> void {
                    iterate(-half_range, half_range+1, |i : int| -> void {
                        let stencil_index = i + half_range + ((j + half_range) * range);
                        let stencil_val = stencil[stencil_index];
                        sum += arr[x + i][y + j] * stencil_val;
                    });
                });
                out_fun(sum);
                // relative indices
                out(sum, 1, -1);
            }

            body(get_local_id(0), get_local_id(1), width, arr, out_fun) {
                let mut sum = 0.0f;

                // ... compute phase 1
                ... = temp[x, y] + arr[x-1, y+1];

                temp[x, y] = result;
                sync(temp);

                // ... compute phase 2
                ... = temp[x, y] + temp[x-1, y+1];

                out_fun(sum);
            }

            
            // ulitmate syntax
            sm = map<Shared>(...);
            // compute phase 1
            body1(...);
            sync(sm);
            //compute phase 2
            body2(...);
        });
    });

    synchronize(GPU1);
    synchronize(GPU2);
}
















fn iteration(width : int, height : int, img : [float], body : fn(int, int, [float]) -> void) -> void {
    // slice memory
    let mut cpu_slice1 = slice(img, 0,       0, width/2, height);
    let mut cpu_slice2 = slice(img, width/2, 0, width/2, height);
    let mut gpu_img1 = map<GPU1>(cpu_slice1);
    let mut gpu_img2 = map<GPU2>(cpu_slice2);

    let dim = (width/2, height, 1);
    let block = (32, 4, 1);

    let handle1 = async(|| -> void {
        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body(tid_x, tid_y, gpu_img1);
        });
    });

    let handle2 = async(|| -> void {
        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body(tid_x, tid_y, gpu_img2);
        });
    });

    let gpu_mems = [[float] * 2];
    gpu_mems[0] = gpu_img1;
    gpu_mems[1] = gpu_img2;
    let num_devices = 2;
    let handles = [float * 2];
    iterate(0, num_devices+1, |i : int| -> void {
        body(tid_x, tid_y + i * nvvm_read_ptx_sreg_ntid_y());
        handles[i] = async(|| -> void {
            nvvm(1, dim, block, || -> void {
                let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
                let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

                body(tid_x, tid_y, gpu_mems[i]);
            });
        });
    });

    // synchronize explicitly on handles
    synchronize(handle1);
    synchronize(handle2);
    // alternatively synchronize on GPU devices
    synchronize(GPU1);
    synchronize(GPU2);
}


fn iteration(width : int, height : int, img : [float], body : fn(int, int, [float], [float]) -> void) -> void {
    // slice memory
    let mut cpu_slice1 = slice(img, 0,       0, width/2, height);
    let mut cpu_slice2 = slice(img, width/2, 0, width/2, height);
    let mut gpu_img1 = map<GPU1>(cpu_slice1);
    let mut gpu_img2 = map<GPU2>(cpu_slice2);

    let dim = (width/2, height, 1);
    let block = (32, 4, 1);

    let handle1 = async(|| -> void {
        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            let mut sm = sm_array(block[0], block[1]);
            let sm_x = nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let sm_y = nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            // GPU execution with dedicated scratchpad memory
            let offset_x = 0, offset_y = 0;
            sm = map<SM>(gpu_img1, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);
            // execution with scratchpad memory mapped to global memory
            sm = map<PROXY>(gpu_img1, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);

            body(tid_x, tid_y, gpu_img1, sm);
        });
    });

    let handle2 = async(|| -> void {
        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            let mut sm = sm_array(block[0], block[1]);
            let sm_x = nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let sm_y = nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            // GPU execution with dedicated scratchpad memory
            let offset_x = 0, offset_y = 0;
            sm = map<SM>(gpu_img2, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);
            // execution with scratchpad memory mapped to global memory
            sm = map<PROXY>(gpu_img2, sm_x-offset_x, sm_y-offset_y, block[0]+2*offset_x, block[1]+2*offset_y);

            body(tid_x, tid_y, gpu_img2, sm);
        });
    });

    // synchronize explicitly on handles
    synchronize(handle1);
    synchronize(handle2);
    // alternatively synchronize on GPU devices
    synchronize(GPU1);
    synchronize(GPU2);
}


fn main() -> [float] {
    let width   = 2048;
    let height  = 2048;
    let mut img = array(4, width, height);

    let stencil : [float * 3] = [ 0.25f, 0.50f, 0.25f ];

    convolution_separable(img, stencil, stencil);

    return img;
}


// explicit variant
fn convolution_separable(img: [float],
                         stencil_row: [float * 3 * 3],
                         stencil_col: [float * 3 * 3]) -> [float] {
    // temporary memory
    let img_gpu : [float] = map<GPU>(img);
    let tmp_gpu : [float] = array<GPU>(img.width(), img.height());

    // constant memory for stencil
    let stencil_row_gpu : [float * 3 * 3] = map<CM>(stencil_row);
    let stencil_col_gpu : [float * 3 * 3] = map<CM>(stencil_col);

    for gid_x, gid_y in range(tmp_gpu) run on GPU {
        // thread index
        let tid_x = get_thread_idx(0);
        let tid_y = get_thread_idx(1);

        // shared memory for data staging
        let mut sdata : [float, float] = array<SM>(get_blocking(1), get_blocking(2));

        // load data to shared memory
        sdata[get_thread_idx(1), get_thread_idx(0)] = img_gpu[gid_x, gid_y];

        // synchronize
        barrier(SM);

        // apply stencil
        tmp_gpu[gid_x, gid_y] = @convolve(sdata, stencil_row_gpu);
    }

    for gid_x, gid_y in range(img_gpu) run on GPU {
        // thread index
        let tid_x = get_thread_idx(0);
        let tid_y = get_thread_idx(1);

        // shared memory for data staging
        let mut sdata : [float, float] = array<SM>(get_blocking(1), get_blocking(2));

        // load data to shared memory
        sdata[get_thread_idx(1), get_thread_idx(0)] = tmp_gpu[gid_x, gid_y];

        // synchronize
        barrier(SM);

        // apply stencil
        img_gpu[gid_x, gid_y] = @convolve(sdata, stencil_col_gpu);
    }

    // map GPU to CPU memory using map<CPU>()
    img = map(img_gpu);
}


// implicit variant
fn convolution_separable(img: [float],
                         stencil_row: [float * 3 * 3],
                         stencil_col: [float * 3 * 3]) -> [float] {
    let tmp : [float] = array(img.width(), img.height());

    for gid_x, gid_y in range(tmp) {
        // thread index
        let tid_x = get_thread_idx(0);
        let tid_y = get_thread_idx(1);

        // shared memory for data staging
        let mut sdata : [float, float] = array(get_blocking(1), get_blocking(2));

        // load data to shared memory
        sdata[get_thread_idx(1), get_thread_idx(0)] = img[gid_x, gid_y];

        // synchronize
        barrier();

        // apply stencil
        tmp[gid_x, gid_y] = @convolve(sdata, stencil_row);
    }

    for gid_x, gid_y in range(img) {
        // thread index
        let tid_x = get_thread_idx(0);
        let tid_y = get_thread_idx(1);

        // shared memory for data staging
        let mut sdata : [float, float] = array(get_blocking(1), get_blocking(2));

        // load data to shared memory
        sdata[get_thread_idx(1), get_thread_idx(0)] = tmp[gid_x, gid_y];

        // synchronize
        barrier();

        // apply stencil
        img[gid_x, gid_y] = @convolve(sdata, stencil_col);
    }
}

