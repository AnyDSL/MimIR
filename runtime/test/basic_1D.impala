extern all_on_gpu(float[], fn(int, int, int) -> void) -> int;
extern array(int) -> float[];

fn idx(x : int, y: int, z : int, width : int, height : int, depth : int) -> int {
    return x + width * y + z * width * height;
}

fn main() -> float[] {
    val width   = 1024;
    val height  = 1024;
    val depth   = 1;
    val range   = 3;
    val size    = 2*range;
    val out     = array(width * height * depth);
    val in      = array(width * height * depth);
    // TODO: mask as a C const array
    val mask    = array(size * size);

    // convolution filter mask for 3x3 gaussian blur
    mask[0] = 0.057118f; mask[1] = 0.124758f; mask[2] = 0.057118f;
    mask[3] = 0.124758f; mask[4] = 0.272496f; mask[5] = 0.124758f;
    mask[6] = 0.057118f; mask[7] = 0.124758f; mask[8] = 0.057118f;

    for (var iter=0; iter<100; ++iter) {
        // TODO: howto switch pointers?
        // val *float[] tmp;
        // tmp = in;
        // in = out;
        // out = tmp;
        all_on_gpu(out, |x : int, y : int, z : int| -> void {
            val index = x + width * y + height * depth * z;
            // TODO: call to idx triggers assertion
            //val index = idx(x, y, z, width, height, depth);
            val a2 = out[index];
            val b2 = in[index];
            val c2 = @convolve(in, mask, 3, x, y, z, width, height, depth);
            // TODO: passing 'range' instead of '3' results in infintie loop during
            // compilation / partial evaluation
            //val c2 = @convolve(in, mask, range, x, y, z, width, height, depth);
            out[index] = c2 + a2 + b2;
        });
    }

    return out;
}

fn convolve(arr : float[], mask : float[], range : int, x : int, y : int, z : int, width : int, height : int, depth : int) -> float {
    var sum = 0.0f;
    val msize = 2*range;

    // TODO:
    // - iterate over C const arrays
    // - consider only non-null values
    // - get value and index of current element
    // for (val cur not null in mask.values(), val idx in mask.index()) {
    //   sum += val * arr((x, y, z) + idx);
    // }
    for (var yf=-range; yf<range; ++yf) {
        for (var xf=-range; xf<range; ++xf) {
            val index = x + xf + width * (y + yf) + width * height * z;
            val imask = range + xf +  msize * (range + yf);
            // TODO: propagate mask[imask] in case mask is a C const array
            sum += mask[imask] * arr[index];
        }
    }

    return sum;
}

