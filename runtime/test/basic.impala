extern all_on_gpu([float], fn(fn() -> int, fn() -> int, fn() -> int) -> void) -> int;
extern array(int) -> [float];
extern sqrt(float) -> float;

fn idx(x : int, y: int, z : int, width : int, height : int) -> int {
    return x + width * y + z * width * height;
}

fn main() -> [float] {
    let width   = 1024;
    let height  = 1024;
    let range   = 3;
    let mut arr = array(width * height);
    let mut out = array(width * height);
    // convolution filter mask for 3x3 gaussian blur
    let mask : [float * 3 * 3] = [
        [0.057118f, 0.124758f, 0.057118f],
        [0.124758f, 0.272496f, 0.124758f],
        [0.057118f, 0.124758f, 0.057118f]];

    for (let mut iter=0; iter<100; ++iter) {
        let mut l2sum = 0.0f;
        all_on_gpu(out, |x : fn() -> int, y : fn() -> int, z : fn() -> int| -> void {
            let index = x() + width * y();
            // TODO: call to idx triggers assertion
            //let index = idx(x(), y(), z(), width, height);
            let a2 = out[index];
            let b2 = arr[index];
            let c2 = @convolve(arr, mask, 3, x(), y(), z(), width, height);
            // TODO: passing 'range' instead of '3' results in infinite loop
            // during compilation / partial evaluation
            //let c2 = @convolve(arr, mask, range, x(), y(), z(), width, height);
            out[index] = c2 + a2 + b2;

            // TODO: support reductions
            l2sum += c2*c2;
        });
        // TODO: introduce casts, implicit or explicit
        //let l2norm = sqrt(l2sum)/(width*height);
        let l2norm = sqrt(l2sum)/(1024.f*1024.f);

        let mut tmp : [float];
        tmp = arr;
        arr = out;
        out = tmp;
    }

    return out;
}

fn convolve(arr : [float], mask : [float * 3 * 3], range : int, x : int, y : int, z : int, width : int, height : int) -> float {
    // TODO:
    // - iterate over C const arrays
    // - consider only non-null values
    // - get value and index of current element
    // for (let cur not null in mask.values(), let idx in mask.index()) {
    //   sum += let * arr((x, y, z) + idx);
    // }
    let mut sum = 0.0f;

    for (let mut yf=-range; yf<range; ++yf) {
        for (let mut xf=-range; xf<range; ++xf) {
            let index = x + xf + width * (y + yf) + width * height * z;
            // TODO: propagate mask[imask] in case mask is a C const array
            sum += mask[range + xf][range +yf] * arr[index];
        }
    }

    return sum;
}

