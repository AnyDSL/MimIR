fn iteration(width : int, height : int, body : fn(int, int) -> void) -> void {
    let dim = (width, height, 1);
    let block = (128, 1, 1);

    nvvm(1, dim, block, || -> void {
        let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
        let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

        body(tid_x, tid_y);
    });
}

fn iteration_bounds(width : int, height : int, range : int,
                    clamp_lower : fn(int, int) -> int,
                    clamp_upper : fn(int, int) -> int,
                    clamp_none : fn(int, int) -> int,
                    body : fn(int, int, fn(int, int) -> int, fn(int, int) -> int, fn(int, int) -> int, fn(int, int) -> int) -> void
                   ) -> void {
    let bhr = range / 2;
    let block = (128, bhr, 1);

    let Bounds2D = [
        (0               , block[0]        , 0                , block[1]),
        (block[0]        , width - block[0], 0                , block[1]),
        (width - block[0], width           , 0                , block[1]),

        (0               , block[0]        , height - block[1], height),
        (block[0]        , width - block[0], height - block[1], height),
        (width - block[0], width           , height - block[1], height),

        (0               , block[0]        , block[1]         , height - block[1]),
        (width - block[0], width           , block[1]         , height - block[1]),
        (block[0]        , width - block[0], block[1]         , height - block[1])
    ];

    @iterate(0, 9, |i : int| -> void {
        let mut left = clamp_none;
        let mut right = clamp_none;
        let mut top = clamp_none;
        let mut bottom = clamp_none;
        // 0 --- 1 --- 2
        // 6 --- 8 --- 7
        // 3 --- 4 --- 5

        // left
        if (i == 0) {
            left = clamp_lower;
            top = clamp_lower;
        }
        if (i == 6) {
            left = clamp_lower;
        }
        if (i == 3) {
            left = clamp_lower;
            bottom = clamp_upper;
        }
        // top + bottom
        if (i == 1)
            top = clamp_lower;
        if (i == 4)
            bottom = clamp_upper;
        // right
        if (i == 2) {
            right = clamp_upper;
            top = clamp_lower;
        }
        if (i == 7) {
            right = clamp_upper;
        }
        if (i == 5) {
            right = clamp_upper;
            bottom = clamp_upper;
        }
        // center case
        if(i == 8) {
            // ignore this case
        }

        let bounds = Bounds2D[i];
        let dim = (bounds[1] - bounds[0], bounds[3] - bounds[2], 1);

        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body(tid_x + bounds[0], tid_y + bounds[2], left, right, top, bottom);
        });
    });
}

fn iteration_advanced(width : int, height : int,
                      arr : [float], out : [float],
                      body : fn(int, int, [float], [float]) -> void
                     ) -> void {
    @iterate_times_two(1, 16+1, |unroll : int| -> void {
        let dim = (width, height/unroll, 1);
        let block = (128, 1, 1);

        // 0 -> global
        // 1 -> texture
        // 2 -> shared
        let gmem_arr = map(arr, 1, 0, (0, 0, 0), (width, height, 0));
        let gmem_out = map(out, 1, 0, (0, 0, 0), (width, height, 0));

        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y() * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body(tid_x, tid_y + i * nvvm_read_ptx_sreg_ntid_y(), gmem_arr, gmem_out);
            });
        });

        let tex_arr = map(arr, 1, 1, (0, 0, 0), (width, height, 0));

        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y() * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body(tid_x, tid_y + i * nvvm_read_ptx_sreg_ntid_y(), tex_arr, gmem_out);
            });
        });
    });
}

fn iteration_sep(width : int, height : int,
                 body_col : fn(int, int) -> void,
                 body_row : fn(int, int) -> void
                ) -> void {
    let dim = (width, height, 1);
    let block = (128, 1, 1);

    nvvm(1, dim, block, || -> void {
        let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
        let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

        body_col(tid_x, tid_y);
    });
    nvvm(1, dim, block, || -> void {
        let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
        let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

        body_row(tid_x, tid_y);
    });
}

fn iteration_sep_bounds(width : int, height : int, range : int,
                    clamp_lower : fn(int, int) -> int,
                    clamp_upper : fn(int, int) -> int,
                    clamp_none : fn(int, int) -> int,
                    body_col : fn(int, int, fn(int, int) -> int, fn(int, int) -> int, fn(int, int) -> int, fn(int, int) -> int) -> void,
                    body_row : fn(int, int, fn(int, int) -> int, fn(int, int) -> int, fn(int, int) -> int, fn(int, int) -> int) -> void
                   ) -> void {
    let bhr = range / 2;
    let block = (128, bhr, 1);

    let Bounds2DRow = [
        (0               , block[0]),
        (block[0]        , width - block[0]),
        (width - block[0], width)
    ];
    let Bounds2DCol = [
        (0                  , block[1]),
        (block[1]           , height - block[1]),
        (height - block[1]  , height)
    ];

    @iterate(0, 3, |i : int| -> void {
        let mut top = clamp_none;
        let mut bottom = clamp_none;
        // 0
        // 1
        // 2

        // top
        if (i == 0) top = clamp_lower;
        // bottom
        if (i == 2) bottom = clamp_upper;

        let bounds = Bounds2DCol[i];
        let dim = (width, bounds[1] - bounds[0], 1);

        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body_col(tid_x, tid_y + bounds[0], clamp_none, clamp_none, top, bottom);
        });
    });

    @iterate(0, 3, |i : int| -> void {
        let mut left = clamp_none;
        let mut right = clamp_none;
        // 0 --- 1 --- 2

        // left
        if (i == 0) left = clamp_lower;
        // right
        if (i == 2) right = clamp_upper;

        let bounds = Bounds2DRow[i];
        let dim = (bounds[1] - bounds[0], height, 1);

        nvvm(1, dim, block, || -> void {
            let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
            let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

            body_row(tid_x + bounds[0], tid_y, left, right, clamp_none, clamp_none);
        });
    });
}

fn iteration_sep_advanced(width : int, height : int,
                          arr : [float], out : [float],
                          body_col : fn(int, int, [float], [float]) -> void,
                          body_row : fn(int, int, [float], [float]) -> void
                         ) -> void {
    let dim = (width, height, 1);
    let block = (128, 1, 1);

    let tmp = array(4, width, height);

    let tex_col = map(arr, 1, 1, (0, 0, 0), (width, height, 0));
    let out_col = map(tmp, 1, 0, (0, 0, 0), (width, height, 0));

    nvvm(1, dim, block, || -> void {
        let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
        let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

        body_col(tid_x, tid_y, tex_col, out_col);
    });

    //unmap(tex_col, 1, 1);
    //unmap(out_col);

    let tex_row = map(tmp, 1, 1, (0, 0, 0), (width, height, 0));
    let out_row = map(out, 1, 0, (0, 0, 0), (width, height, 0));

    nvvm(1, dim, block, || -> void {
        let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
        let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

        body_row(tid_x, tid_y, tex_row, out_row);
    });

    //unmap(tex_row);
    //unmap(out_row);

    free_array(tmp);
}

fn iteration_multi(width : int, height : int,
                   arr : [float], out : [float],
                   body : fn(int, int, [float], [float]) -> void
                  ) -> void {
    let dim = (width, height/2, 1);
    let block = (128, 1, 1);

    let map_arr_GPU1 = map(arr, 1, 0, (0, 0, 0),        (width, height/2, 0));
    let map_out_GPU1 = map(out, 1, 0, (0, 0, 0),        (width, height/2, 0));

    nvvm(1, dim, block, || -> void {
        let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
        let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

        body(tid_x, tid_y, map_arr_GPU1, map_out_GPU1);
    });

    let map_arr_GPU2 = map(arr, 2, 0, (0, height/2, 0), (width, height/2, 0));
    let map_out_GPU2 = map(out, 2, 0, (0, height/2, 0), (width, height/2, 0));

    nvvm(2, dim, block, || -> void {
        let tid_x = nvvm_read_ptx_sreg_tid_x() + nvvm_read_ptx_sreg_ntid_x() * nvvm_read_ptx_sreg_ctaid_x();
        let tid_y = nvvm_read_ptx_sreg_tid_y() + nvvm_read_ptx_sreg_ntid_y() * nvvm_read_ptx_sreg_ctaid_y();

        body(tid_x, tid_y, map_arr_GPU2, map_out_GPU2);
    });
}
