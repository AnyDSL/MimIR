intrinsic exp(float) -> float;
fn expf(a: float) -> float {
    return exp(a);
}

fn iteration(width : int, height : int, body : fn(int, int) -> void) -> void {
    let unroll = 1;
    let dim = (width, height/unroll, 1);
    let block = (128, 1, 1);

    opencl(1, dim, block, || -> void {
        let gid_x = global_id(0);
        let gid_y = local_id(1) + local_size(1) * group_id(1) * unroll;

        @iterate(0, unroll, |i : int| -> void {
            body(gid_x, gid_y + i * local_size(1));
        });
    });
}

fn iteration_bounds(width : int, height : int, range : int,
                    body : fn(int, int, int) -> void
                   ) -> void {
    // define the unroll factor
    let unroll = 1;
    // compute the number of blocks required for boundary handling
    let mut bhr = range / 2;
    if (bhr % unroll==0) bhr = bhr / unroll;
    else bhr = bhr / unroll + 1;
    let block = (128, bhr, 1);

    // bounds account for unroll factor
    let hu = height/unroll;
    let Bounds2D = [
        (0               , block[0]        , 0            , block[1]),
        (block[0]        , width - block[0], 0            , block[1]),
        (width - block[0], width           , 0            , block[1]),

        (0               , block[0]        , block[1]     , hu - block[1]),
        (block[0]        , width - block[0], block[1]     , hu - block[1]),
        (width - block[0], width           , block[1]     , hu - block[1]),

        (0               , block[0]        , hu - block[1], hu),
        (block[0]        , width - block[0], hu - block[1], hu),
        (width - block[0], width           , hu - block[1], hu)
    ];

    iterate(0, 9, |region : int| -> void {
        let bounds = Bounds2D[region];
        let dim = (bounds[1] - bounds[0], bounds[3] - bounds[2], 1);

        opencl(1, dim, block, || -> void {
            let gid_x = global_id(0);
            let gid_y = local_id(1) + local_size(1) * group_id(1) * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body(gid_x + bounds[0], gid_y + bounds[2] + i * local_size(1), region);
            });
        });
    });
}

fn iteration_advanced(width : int, height : int, ksize : int,
                      arr : [float], out : [float],
                      body : fn(int, int, [float], [float], int, int, int) -> void
                     ) -> void {
    iterate_times_two(1, 16+1, |unroll : int| -> void {
        // compute the number of blocks required for boundary handling
        let mut bbh = ksize / 2;
        if (bbh % unroll==0) bbh = bbh / unroll;
        else bbh = bbh / unroll + 1;

        let dim = (width, height/unroll, 1);
        let block = (128/bbh, bbh, 1);

        // compute number of steps required to stage data to shared memory
        let ksize2 = ksize / 2;
        let steps_x = 2;
        let offset_y = (ksize%block[1]==0)?0:1;
        let steps_y = unroll + ksize/block[1] + offset_y;

        // 0 -> global
        // 2 -> shared
        let dev = 1;
        let gmem_arr = map(arr, dev, 0, (0, 0, 0), (width, height, 1));
        let gmem_out = map(out, dev, 0, (0, 0, 0), (width, height, 1));

        opencl(dev, dim, block, || -> void {
            let tid_x = local_id(0);
            let tid_y = local_id(1);
            let bid_x = group_id(0);
            let bid_y = group_id(1);
            let bdim_x = local_size(0);
            let bdim_y = local_size(1);
            let gid_x = global_id(0);
            let gid_y = tid_y + bdim_y * bid_y * unroll;

            let smem = map(gmem_arr, 1, 2, (0, 0, 0), (block[0] + 2*ksize2, block[1]*unroll + 2*ksize2, 1));
            let lstride = block[0] + 2*ksize2;

            for (let mut y=0; y<steps_y; ++y) {
                let lid_y = tid_y + y*bdim_y;
                let mut idx_y = gid_y - ksize2 + y*bdim_y;
                idx_y = clamp_upper(idx_y, height);
                idx_y = clamp_lower(idx_y, 0);
                for (let mut x=0; x<steps_x; ++x) {
                    let lid_x = tid_x + x*bdim_x;
                    let mut idx_x = gid_x - ksize2 + x*bdim_x;
                    idx_x = clamp_lower(idx_x, 0);
                    idx_x = clamp_upper(idx_x, width);

                    if (lid_x < block[0] + 2*ksize2 &&
                        lid_y < block[1]*unroll + 2*ksize2)
                        smem[lid_y * lstride + lid_x] = gmem_arr[idx_y * width + idx_x];
                }
            }

            // CLK LOCAL MEM FENCE -> 1
            // CLK_GLOBAL_MEM_FENCE -> 2
            barrier(2);

            @iterate(0, unroll, |i : int| -> void {
                body(gid_x, gid_y + i * bdim_y, smem, gmem_out, tid_x+ksize2, tid_y+ksize2 + i * bdim_y, lstride);
            });
        });
    });
}

fn iteration_sep(width : int, height : int,
                 body_col : fn(int, int) -> void,
                 body_row : fn(int, int) -> void
                ) -> void {
    let unroll = 1;
    let dim = (width, height/unroll, 1);
    let block = (128, 1, 1);

    opencl(1, dim, block, || -> void {
        let gid_x = global_id(0);
        let gid_y = local_id(1) + local_size(1) * group_id(1) * unroll;

        @iterate(0, unroll, |i : int| -> void {
            body_col(gid_x, gid_y + i * local_size(1));
        });
    });
    opencl(1, dim, block, || -> void {
        let gid_x = global_id(0);
        let gid_y = local_id(1) + local_size(1) * group_id(1) * unroll;

        @iterate(0, unroll, |i : int| -> void {
            body_row(gid_x, gid_y + i * local_size(1));
        });
    });
}

fn iteration_sep_bounds(width : int, height : int, range : int,
                    body_col : fn(int, int, int) -> void,
                    body_row : fn(int, int, int) -> void
                   ) -> void {
    // define the unroll factor
    let unroll = 1;
    // compute the number of blocks required for boundary handling
    let mut bhr = range / 2;
    if (bhr % unroll==0) bhr = bhr / unroll;
    else bhr = bhr / unroll + 1;
    let block = (128, bhr, 1);

    let hu = height / unroll;
    let Bounds2DCol = [
        (0               , block[1]),
        (block[1]        , hu - block[1]),
        (hu - block[1]   , hu)
    ];

    iterate(0, 3, |region : int| -> void {
        let bounds = Bounds2DCol[region];
        let dim = (width, bounds[1] - bounds[0], 1);

        opencl(1, dim, block, || -> void {
            let gid_x = global_id(0);
            let gid_y = local_id(1) + local_size(1) * group_id(1) * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body_col(gid_x, gid_y + bounds[0] + i * local_size(1), region);
            });
        });
    });

    let Bounds2DRow = [
        (0               , block[0]),
        (block[0]        , width - block[0]),
        (width - block[0], width)
    ];

    iterate(0, 3, |region : int| -> void {
        let bounds = Bounds2DRow[region];
        let dim = (bounds[1] - bounds[0], height/unroll, 1);

        opencl(1, dim, block, || -> void {
            let gid_x = global_id(0);
            let gid_y = local_id(1) + local_size(1) * group_id(1) * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body_row(gid_x + bounds[0], gid_y + i * local_size(1), region);
            });
        });
    });
}

fn iteration_sep_advanced(width : int, height : int,
                          arr : [float], out : [float],
                          body_col : fn(int, int, [float], [float]) -> void,
                          body_row : fn(int, int, [float], [float]) -> void
                         ) -> void {
    // CPU:   1
    // GPU-0: 2
    // GPU-1: 3
    let dev = 2;
    let dim = (width, height, 1);
    let block = (128, 1, 1);

    let tmp = array(4, width, height);

    let arr_col = map(arr, dev, 0, (0, 0, 0), (width, height, 1));
    let out_col = map(tmp, dev, 0, (0, 0, 0), (width, height, 1));

    opencl(dev, dim, block, || -> void {
        let gid_x = global_id(0);
        let gid_y = global_id(1);

        body_col(gid_x, gid_y, arr_col, out_col);
    });

    //unmap(arr_col, dev, 1);
    //unmap(out_col);

    let arr_row = map(tmp, dev, 0, (0, 0, 0), (width, height, 1));
    let out_row = map(out, dev, 0, (0, 0, 0), (width, height, 1));

    opencl(dev, dim, block, || -> void {
        let gid_x = global_id(0);
        let gid_y = global_id(1);

        body_row(gid_x, gid_y, arr_row, out_row);
    });

    //unmap(arr_row);
    //unmap(out_row);

    free_array(tmp);
}

fn iteration_multi(width : int, height : int,
                   arr : [float], out : [float],
                   body : fn(int, int, [float], [float]) -> void
                  ) -> void {
    let dim = (width, height/2, 1);
    let block = (128, 1, 1);

    let map_arr_CPU = map(arr, 1, 0, (0, 0, 0),        (width, height/2, 1));
    let map_out_CPU = map(out, 1, 0, (0, 0, 0),        (width, height/2, 1));

    opencl(1, dim, block, || -> void {
        let gid_x = global_id(0);
        let gid_y = global_id(1);

        body(gid_x, gid_y, map_arr_CPU, map_out_CPU);
    });

    let map_arr_GPU = map(arr, 2, 0, (0, height/2, 0), (width, height/2, 1));
    let map_out_GPU = map(out, 2, 0, (0, height/2, 0), (width, height/2, 1));

    opencl(2, dim, block, || -> void {
        let gid_x = global_id(0);
        let gid_y = global_id(1);

        body(gid_x, gid_y, map_arr_GPU, map_out_GPU);
    });
}
