fn iteration(width : int, height : int, body : fn(int, int) -> void) -> void {
    let unroll = 1;
    let dim = (width, height/unroll, 1);
    let block = (128, 1, 1);

    spir(1, dim, block, || -> void {
        let tid_x = int64_to_int32(get_global_id(0));
        let tid_y = int64_to_int32(get_local_id(1)) + int64_to_int32(get_local_size(1) * get_group_id(1)) * unroll;

        @iterate(0, unroll, |i : int| -> void {
            body(tid_x, tid_y + i * int64_to_int32(get_local_size(1)));
        });
    });
}

fn iteration_bounds(width : int, height : int, range : int,
                    body : fn(int, int, int) -> void
                   ) -> void {
    // define the unroll factor
    let unroll = 1;
    // compute the number of blocks required for boundary handling
    let mut bhr = range / 2;
    if (bhr % unroll==0) bhr = bhr / unroll;
    else bhr = bhr / unroll + 1;
    let block = (128, bhr, 1);

    // bounds account for unroll factor
    let hu = height/unroll;
    let Bounds2D = [
        (0               , block[0]        , 0            , block[1]),
        (block[0]        , width - block[0], 0            , block[1]),
        (width - block[0], width           , 0            , block[1]),

        (0               , block[0]        , block[1]     , hu - block[1]),
        (block[0]        , width - block[0], block[1]     , hu - block[1]),
        (width - block[0], width           , block[1]     , hu - block[1]),

        (0               , block[0]        , hu - block[1], hu),
        (block[0]        , width - block[0], hu - block[1], hu),
        (width - block[0], width           , hu - block[1], hu)
    ];

    @iterate(0, 9, |region : int| -> void {
        let bounds = Bounds2D[region];
        let dim = (bounds[1] - bounds[0], bounds[3] - bounds[2], 1);

        spir(1, dim, block, || -> void {
            let tid_x = int64_to_int32(get_global_id(0));
            let tid_y = int64_to_int32(get_local_id(1)) + int64_to_int32(get_local_size(1) * get_group_id(1)) * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body(tid_x + bounds[0], tid_y + bounds[2] * unroll + i * int64_to_int32(get_local_size(1)), region);
            });
        });
    });
}

fn iteration_advanced(width : int, height : int,
                      arr : [float], out : [float],
                      body : fn(int, int, [float], [float]) -> void
                     ) -> void {
    @iterate_times_two(1, 16+1, |unroll : int| -> void {
        let dim = (width, height/unroll, 1);
        let block = (128, 1, 1);

        // 0 -> global
        let gmem_arr = map(arr, 1, 0, (0, 0, 0), (width, height, 0));
        let gmem_out = map(out, 1, 0, (0, 0, 0), (width, height, 0));

        spir(1, dim, block, || -> void {
            let tid_x = int64_to_int32(get_global_id(0));
            let tid_y = int64_to_int32(get_local_id(1)) + int64_to_int32(get_local_size(1) * get_group_id(1)) * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body(tid_x, tid_y + i * int64_to_int32(get_local_size(1)), gmem_arr, gmem_out);
            });
        });
    });
}

fn iteration_sep(width : int, height : int,
                 body_col : fn(int, int) -> void,
                 body_row : fn(int, int) -> void
                ) -> void {
    let dim = (width, height, 1);
    let block = (128, 1, 1);

    spir(1, dim, block, || -> void {
        let tid_x = int64_to_int32(get_global_id(0));
        let tid_y = int64_to_int32(get_global_id(1));

        body_col(tid_x, tid_y);
    });
    spir(1, dim, block, || -> void {
        let tid_x = int64_to_int32(get_global_id(0));
        let tid_y = int64_to_int32(get_global_id(1));

        body_row(tid_x, tid_y);
    });
}

fn iteration_sep_bounds(width : int, height : int, range : int,
                    body_col : fn(int, int, int) -> void,
                    body_row : fn(int, int, int) -> void
                   ) -> void {
    // define the unroll factor
    let unroll = 1;
    // compute the number of blocks required for boundary handling
    let mut bhr = range / 2;
    if (bhr % unroll==0) bhr = bhr / unroll;
    else bhr = bhr / unroll + 1;
    let block = (128, bhr, 1);

    let hu = height / unroll;
    let Bounds2DCol = [
        (0               , block[1]),
        (block[1]        , hu - block[1]),
        (hu - block[1]   , hu)
    ];

    @iterate(0, 3, |region : int| -> void {
        let bounds = Bounds2DCol[region];
        let dim = (width, bounds[1] - bounds[0], 1);

        spir(1, dim, block, || -> void {
            let tid_x = int64_to_int32(get_global_id(0));
            let tid_y = int64_to_int32(get_local_id(1)) + int64_to_int32(get_local_size(1) * get_group_id(1)) * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body_col(tid_x, tid_y + bounds[0] * unroll + i * int64_to_int32(get_local_size(1)), region);
            });
        });
    });

    let Bounds2DRow = [
        (0               , block[0]),
        (block[0]        , width - block[0]),
        (width - block[0], width)
    ];

    @iterate(0, 3, |region : int| -> void {
        let bounds = Bounds2DRow[region];
        let dim = (bounds[1] - bounds[0], height/unroll, 1);

        spir(1, dim, block, || -> void {
            let tid_x = int64_to_int32(get_global_id(0));
            let tid_y = int64_to_int32(get_local_id(1)) + int64_to_int32(get_local_size(1) * get_group_id(1)) * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body_row(tid_x + bounds[0], tid_y + i * int64_to_int32(get_local_size(1)), region);
            });
        });
    });
}

fn iteration_sep_advanced(width : int, height : int,
                          arr : [float], out : [float],
                          body_col : fn(int, int, [float], [float]) -> void,
                          body_row : fn(int, int, [float], [float]) -> void
                         ) -> void {
    // CPU:   1 (SPIR)
    // GPU-0: 2
    // GPU-1: 3
    let dev = 1;
    let dim = (width, height, 1);
    let block = (128, 1, 1);

    let tmp = array(4, width, height);

    let arr_col = map(arr, dev, 0, (0, 0, 0), (width, height, 0));
    let out_col = map(tmp, dev, 0, (0, 0, 0), (width, height, 0));

    spir(dev, dim, block, || -> void {
        let tid_x = int64_to_int32(get_global_id(0));
        let tid_y = int64_to_int32(get_global_id(1));

        body_col(tid_x, tid_y, arr_col, out_col);
    });

    //unmap(arr_col, dev, 1);
    //unmap(out_col);

    let arr_row = map(tmp, dev, 0, (0, 0, 0), (width, height, 0));
    let out_row = map(out, dev, 0, (0, 0, 0), (width, height, 0));

    spir(dev, dim, block, || -> void {
        let tid_x = int64_to_int32(get_global_id(0));
        let tid_y = int64_to_int32(get_global_id(1));

        body_row(tid_x, tid_y, arr_row, out_row);
    });

    //unmap(arr_row);
    //unmap(out_row);

    free_array(tmp);
}
