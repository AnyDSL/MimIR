fn iteration(width : int, height : int, body : fn(int, int) -> void) -> void {
    let unroll = 1;
    let dim = (width, height/unroll, 1);
    let block = (128, 1, 1);

    cuda(1, dim, block, || -> void {
        let gid_x = threadIdx_x() + blockDim_x() * blockIdx_x();
        let gid_y = threadIdx_y() + blockDim_y() * blockIdx_y() * unroll;

        @iterate(0, unroll, |i : int| -> void {
            body(gid_x, gid_y + i * blockDim_y());
        });
    });
}

fn iteration_advanced(width : int, height : int,
                      arr : [float], out : [float],
                      body : fn(int, int, [float], [float]) -> void
                     ) -> void {
    iterate_times_two(1, 16+1, |unroll : int| -> void {
        let dim = (width, height/unroll, 1);
        let block = (128, 1, 1);

        // 0 -> global
        // 1 -> texture
        // 2 -> shared
        let gmem_arr = map(arr, 1, 0, (0, 0, 0), (width, height, 1));
        let gmem_out = map(out, 1, 0, (0, 0, 0), (width, height, 1));

        cuda(1, dim, block, || -> void {
            let gid_x = threadIdx_x() + blockDim_x() * blockIdx_x();
            let gid_y = threadIdx_y() + blockDim_y() * blockIdx_y() * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body(gid_x, gid_y + i * blockDim_y(), gmem_arr, gmem_out);
            });
        });

        let tex_arr = map(arr, 1, 1, (0, 0, 0), (width, height, 1));

        cuda(1, dim, block, || -> void {
            let gid_x = threadIdx_x() + blockDim_x() * blockIdx_x();
            let gid_y = threadIdx_y() + blockDim_y() * blockIdx_y() * unroll;

            @iterate(0, unroll, |i : int| -> void {
                body(gid_x, gid_y + i * blockDim_y(), tex_arr, gmem_out);
            });
        });
    });
}

fn iteration_sep_bounds(width : int, height : int, range : int,
                    body_col : fn(int, int, int) -> void,
                    body_row : fn(int, int, int) -> void
                   ) -> void {
    // define the unroll factor
    let unroll = 1;
    // define if we want to generate one big kernel or multiple kernels
    let big_kernel = false;


    // compute the number of blocks required for boundary handling
    let mut bbh = range / 2;
    if (bbh % unroll==0) bbh = bbh / unroll;
    else bbh = bbh / unroll + 1;
    let block = (128, bbh, 1);

    if (big_kernel) {
        let dim = (width, height/unroll, 1);

        // column component
        cuda(1, dim, block, || -> void {
            let tid_x = threadIdx_x();
            let tid_y = threadIdx_y();
            let bid_x = blockIdx_x();
            let bid_y = blockIdx_y();
            let bdim_x = blockDim_x();
            let bdim_y = blockDim_y();
            let gdim_x = gridDim_x();
            let gdim_y = gridDim_y();
            let gid_x = tid_x + bdim_x * bid_x;
            let gid_y = tid_y + bdim_y * bid_y * unroll;

            // 0
            // 1
            // 2
            if (bid_y < 1) {                                // top: 0
                @iterate(0, unroll, |i : int| -> void {
                    body_col(gid_x, gid_y + i * blockDim_y(), 0);
                });
            } else
            if (bid_y >= gdim_y-1) {                        // bottom: 2
                @iterate(0, unroll, |i : int| -> void {
                    body_col(gid_x, gid_y + i * blockDim_y(), 2);
                });
            } else
            // no border handling - hack for old hardware
            if (bdim_x >= 16) {
                @iterate(0, unroll, |i : int| -> void {
                    body_col(gid_x, gid_y + i * blockDim_y(), 1);
                });
            }
        });

        // row component
        cuda(1, dim, block, || -> void {
            let tid_x = threadIdx_x();
            let tid_y = threadIdx_y();
            let bid_x = blockIdx_x();
            let bid_y = blockIdx_y();
            let bdim_x = blockDim_x();
            let bdim_y = blockDim_y();
            let gdim_x = gridDim_x();
            let gdim_y = gridDim_y();
            let gid_x = tid_x + bdim_x * bid_x;
            let gid_y = tid_y + bdim_y * bid_y * unroll;

            // 0 --- 1 --- 2
            if (bid_x < 1) {                                // left: 0
                @iterate(0, unroll, |i : int| -> void {
                    body_row(gid_x, gid_y + i * blockDim_y(), 0);
                });
            } else
            if (bid_x >= gdim_x-1) {                        // right: 2
                @iterate(0, unroll, |i : int| -> void {
                    body_row(gid_x, gid_y + i * blockDim_y(), 2);
                });
            } else
            // no border handling - hack for old hardware
            if (bdim_x >= 16) {
                @iterate(0, unroll, |i : int| -> void {
                    body_row(gid_x, gid_y + i * blockDim_y(), 1);
                });
            }
        });
    } else {
        let hu = height / unroll;
        let Bounds2DCol = [
            (0               , block[1]),
            (block[1]        , hu - block[1]),
            (hu - block[1]   , hu)
        ];

        iterate(0, 3, |region : int| -> void {
            let bounds = Bounds2DCol[region];
            let dim = (width, bounds[1] - bounds[0], 1);

            cuda(1, dim, block, || -> void {
                let gid_x = threadIdx_x() + blockDim_x() * blockIdx_x();
                let gid_y = threadIdx_y() + blockDim_y() * blockIdx_y() * unroll;

                @iterate(0, unroll, |i : int| -> void {
                    body_col(gid_x, gid_y + bounds[0] + i * blockDim_y(), region);
                });
            });
        });

        let Bounds2DRow = [
            (0               , block[0]),
            (block[0]        , width - block[0]),
            (width - block[0], width)
        ];

        iterate(0, 3, |region : int| -> void {
            let bounds = Bounds2DRow[region];
            let dim = (bounds[1] - bounds[0], height/unroll, 1);

            cuda(1, dim, block, || -> void {
                let gid_x = threadIdx_x() + blockDim_x() * blockIdx_x();
                let gid_y = threadIdx_y() + blockDim_y() * blockIdx_y() * unroll;

                @iterate(0, unroll, |i : int| -> void {
                    body_row(gid_x + bounds[0], gid_y + i * blockDim_y(), region);
                });
            });
        });
    }
}
