fn apply_stencil(range : int, stencil : [float * 5 * 5],
                 x : int, y : int, arr : [float], width : int, height : int,
                 region: int
                ) -> float {
    let mut sum_xxx = 0.0f;
    let half_range = range / 2;

    iterate(-half_range, half_range+1, |j : int| -> void {
        iterate(-half_range, half_range+1, |i : int| -> void {
            let stencil_val = stencil[i + half_range][j + half_range];
            if (stencil_val != 0.0f) {
                let mut idx_x = x + i;
                let mut idx_y = y + j;

                // 0 --- 1 --- 2
                // 3 --- 4 --- 5
                // 6 --- 7 --- 8

                // left
                if (region == 0) idx_x = clamp_lower(idx_x, 0);
                if (region == 3) idx_x = clamp_lower(idx_x, 0);
                if (region == 6) idx_x = clamp_lower(idx_x, 0);

                // right
                if (region == 2) idx_x = clamp_upper(idx_x, width);
                if (region == 5) idx_x = clamp_upper(idx_x, width);
                if (region == 8) idx_x = clamp_upper(idx_x, width);

                // top
                if (region == 0) idx_y = clamp_lower(idx_y, 0);
                if (region == 1) idx_y = clamp_lower(idx_y, 0);
                if (region == 2) idx_y = clamp_lower(idx_y, 0);

                // bottom
                if (region == 6) idx_y = clamp_upper(idx_y, height);
                if (region == 7) idx_y = clamp_upper(idx_y, height);
                if (region == 8) idx_y = clamp_upper(idx_y, height);

                // all in
                if (region == 10) {
                    idx_x = clamp_lower(idx_x, 0);
                    idx_x = clamp_upper(idx_x, width);
                    idx_y = clamp_upper(idx_y, height);
                    idx_y = clamp_lower(idx_y, 0);
                }

                sum_xxx += arr[idx_y * width + idx_x] * stencil_val;
            } else {
                // additional logic for empty stencil value
            }
        });
    });

    return sum_xxx;
}

fn apply_stencil_local(range : int, stencil : [float * 5 * 5],
                 x : int, y : int, arr : [float], width : int, height : int
                ) -> float {
    let mut sum_xxx = 0.0f;
    let half_range = range / 2;

    iterate(-half_range, half_range+1, |j : int| -> void {
        iterate(-half_range, half_range+1, |i : int| -> void {
            let stencil_val = stencil[i + half_range][j + half_range];
            if (stencil_val != 0.0f) {
                sum_xxx += arr[(y + j) * width + x + i] * stencil_val;
            } else {
                // additional logic for empty stencil value
            }
        });
    });

    return sum_xxx;
}

fn apply_stencil_sep(range : int, stencil : [float * 5], x : int, y : int,
                     arr : [float], width : int, height : int, row : bool,
                     region : int
                    ) -> float {
    let mut sum_xxx = 0.0f;
    let half_range = range / 2;
    iterate(-half_range, half_range+1, |i : int| -> void {
        let stencil_val = stencil[i + half_range];
        let mut idx_x = row ? x + i : x;
        let mut idx_y = row ? y : y + i;
        if (row) {
            // 0 --- 1 --- 2

            // left
            if (region == 0) idx_x = clamp_lower(idx_x, 0);
            // right
            if (region == 2) idx_x = clamp_upper(idx_x, width);

            // all in
            if (region == 10) {
                idx_x = clamp_lower(idx_x, 0);
                idx_x = clamp_upper(idx_x, width);
            }
        } else {
            // 0
            // 1
            // 2

            // top
            if (region == 0) idx_y = clamp_lower(idx_y, 0);
            // bottom
            if (region == 2) idx_y = clamp_upper(idx_y, height);

            // all in
            if (region == 10) {
                idx_y = clamp_lower(idx_y, 0);
                idx_y = clamp_upper(idx_y, height);
            }
        }
        sum_xxx += arr[idx_y * width + idx_x] * stencil_val;
    });

    return sum_xxx;
}

fn apply_stencil_row_cpu(range : int, stencil : [float * 5], x : int, y : int,
                         arr : [float], width : int, height : int, region : int
                        ) -> float {
    let mut sum_xxx = 0.0f;
    let half_range = range / 2;
    iterate(-half_range, half_range+1, |i : int| -> void {
        let stencil_val = stencil[i + half_range];
        let mut idx_x = x + i;
        // 0 --- 1 --- 2

        // left
        if (region == 0) idx_x = clamp_lower(idx_x, 0);
        // right
        if (region == 2) idx_x = clamp_upper(idx_x, width);

        // all in
        if (region == 10) {
            idx_x = clamp_lower(idx_x, 0);
            idx_x = clamp_upper(idx_x, width);
        }
        sum_xxx += arr[idx_x] * stencil_val;
    });

    return sum_xxx;
}

fn main() -> int {
    let width   = 4096;
    let height  = 4096;
    let range   = 5;
    let mut arr = array(4, width, height);
    let mut out = array(4, width, height);
    init_rand(arr, width, height);
    init_zero(out, width, height);

    let stencil_sep : [float * 5] = [
          0.070766f, 0.244460f, 0.369546f, 0.244460f, 0.070766f ];

    let stencil : [float * 5 * 5] = [
        [ 0.005008f, 0.017300f, 0.026151f, 0.017300f, 0.005008f ],
        [ 0.017300f, 0.059761f, 0.090339f, 0.059761f, 0.017300f ],
        [ 0.026151f, 0.090339f, 0.136565f, 0.090339f, 0.026151f ],
        [ 0.017300f, 0.059761f, 0.090339f, 0.059761f, 0.017300f ],
        [ 0.005008f, 0.017300f, 0.026151f, 0.017300f, 0.005008f ]];


    //// SS
    //@iteration(width, height, arr, out,
    //    |x : int, y : int, arr : [float], out : [float]| -> void {
    //        out[y*width + x] = apply_stencil(range, stencil, x, y, arr, width, height, 10);
    //    }
    //);

    //// SS + BH
    //@iteration_bounds(width, height, range, arr, out,
    //    |x : int, y : int, arr : [float], out : [float], region : int| -> void {
    //        out[y*width + x] = apply_stencil(range, stencil, x, y, arr,
    //                                         width, height, region);
    //    }
    //);

    //// SS + SEP
    //@iteration_sep(width, height, arr, out,
    //    |x : int, y : int, arr : [float], out : [float]| -> void {
    //        // col component
    //        let is_row = false;
    //        out[y*width + x] = apply_stencil_sep(range, stencil_sep, x, y,
    //                                              arr, width, height, is_row,
    //                                              10);
    //    },
    //    |x : int, y : int, arr : [float], out : [float]| -> void {
    //        // row component
    //        let is_row = true;
    //        out[y*width + x] = apply_stencil_sep(range, stencil_sep, x, y,
    //                                             arr, width, height, is_row,
    //                                             10);
    //    }
    //);

    //// SS + SEP + BH
    //@iteration_sep_bounds(width, height, range, arr, out,
    //    |x : int, y : int, arr : [float], out : [float], region : int| -> void {
    //        // col component
    //        let is_row = false;
    //        out[y*width + x] = apply_stencil_sep(range, stencil_sep, x, y,
    //                                             arr, width, height, is_row,
    //                                             region);
    //    },
    //    |x : int, y : int, arr : [float], out : [float], region : int| -> void {
    //        // row component
    //        let is_row = true;
    //        out[y*width + x] = apply_stencil_sep(range, stencil_sep, x, y,
    //                                             arr, width, height, is_row,
    //                                             region);
    //    }
    //);


    @iteration_advanced(width, height, range, arr, out,
        |x : int, y : int, arr : [float], out : [float], x_in : int, y_in : int, width_in : int| -> void {
            out[y*width + x] = apply_stencil_local(range, stencil, x_in, y_in, arr, width_in, height);
        }
    );

    //@iteration_sep_advanced(width, height, arr, out,
    //    |x : int, y : int, arr : [float], out : [float]| -> void {
    //        // col component
    //        let is_row = false;
    //        out[y*width + x] = apply_stencil_sep(range, stencil_sep, x, y, arr,
    //                                             width, height, is_row, 10);
    //    },
    //    |x : int, y : int, arr : [float], out : [float]| -> void {
    //        // row component
    //        let is_row = true;
    //        out[y*width + x] = apply_stencil_sep(range, stencil_sep, x, y, arr,
    //                                             width, height, is_row, 10);
    //    }
    //);

    //// CPU variant: IL + SS
    //@iteration_sep_advanced(width, height, arr, out,
    //    |x : int, y : int, arr : [float], out : [float]| -> void {
    //        let is_row = false;
    //        out[x] = apply_stencil_sep(range, stencil_sep, x, y, arr, width,
    //                                   height, is_row, 10);
    //    },
    //    |x : int, y : int, arr : [float], out : [float]| -> void {
    //        out[y*width + x] = apply_stencil_row_cpu(range, stencil_sep, x, y,
    //                                                 arr, width, height, 10);
    //    }
    //);

    //// CPU variant IL + SS + BH
    //@iteration_sep_bounds_advanced(width, height, range, arr, out,
    //    |x : int, y : int, arr : [float], out : [float], region : int| -> void {
    //        let is_row = false;
    //        out[x] = apply_stencil_sep(range, stencil_sep, x, y, arr, width,
    //                                   height, is_row, 10);
    //    },
    //    |x : int, y : int, arr : [float], out : [float], region : int| -> void {
    //        out[y*width + x] = apply_stencil_row_cpu(range, stencil_sep, x, y,
    //                                                 arr, width, height, 10);
    //    }
    //);


    let mut passed = 0;

    for (let mut y=0; y<height; ++y) {
        for (let mut x=0; x<width; ++x) {
            let ref = @apply_stencil(range, stencil, x, y, arr,
                                     width, height, 10);
            let mut diff = ref - out[x + y*width];
            if (diff < 0.0f) diff = -diff;
            if (diff > 0.01f) passed++;
        }
    }

    free_array(arr);
    free_array(out);

    return passed;
}
