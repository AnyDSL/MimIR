fn apply_stencil(range : int, stencil : [float * 3 * 3],
                 x : int, y : int, arr : [float], width : int, height : int,
                 lower_x : fn(int, int) -> int,
                 upper_x : fn(int, int) -> int,
                 lower_y : fn(int, int) -> int,
                 upper_y : fn(int, int) -> int) -> float {
    let mut sum = 0.0f;
    let half_range = range / 2;
    iterate(-half_range, half_range+1, |j : int| -> void {
        iterate(-half_range, half_range+1, |i : int| -> void {
            let stencil_val = stencil[i + half_range][j + half_range];
            if (stencil_val != 0.0f) {
                let mut idx_x = lower_x(x + i, 0);
                        idx_x = upper_x(idx_x, width);
                let mut idx_y = lower_y(y + j, 0);
                        idx_y = upper_y(idx_y, height);
                sum += arr[idx_y * width + idx_x] * stencil_val;
            } else {
                // additional logic for empty stencil value
            }
        });
    });

    return sum;
}

fn main() -> int {
    let width   = 2048;
    let height  = 2048;
    let range   = 3;
    let a       = 0.2f;
    let b       = 1.0f - 4.0f * a;
    let mut arr = array(4, width, height);
    let mut out = array(4, width, height);
    init_rand(arr, width, height);
    init_zero(out, width, height);

    let stencil : [float * 3 * 3] = [
        [0.0f, b, 0.0f],
        [   b, a, b   ],
        [0.0f, b, 0.0f]];

    let L : [int * 3 * 2] = [
        [0, 1, width - 1],
        [0, 1, height - 1]];
    let U : [int * 3 * 2] = [
        [1, width - 1, width],
        [1, height - 1, height]];

    // border handling specialization
    // HINT: naive realization which could be created by a domain expert
    let clamp_lower = |idx : int, lower : int| -> int {
        return idx < lower ? lower : idx;
    };
    let clamp_upper = |idx : int, upper : int| -> int {
        return idx >= upper ? upper - 1 : idx;
    };
    let clamp_none = |idx : int, bound : int| -> int {
        return idx;
    };

    getMicroTime();
    iteration_bounds(width, height, clamp_lower, clamp_upper, clamp_none,
        |x : int, y : int, left : fn(int, int) -> int, right : fn(int, int) -> int, top : fn(int, int) -> int, bottom : fn(int, int) -> int| -> void {
            out[y*width + x] = @apply_stencil(range, stencil, x, y, arr,
                                              width, height,
                                              left, right, top, bottom);
        }
    );
    getMicroTime();


    let mut passed = 0;

    let clamp = |idx : int, lower : int, upper : int | -> int {
        return idx < lower ? lower : idx >= upper ? upper-1 : idx;
    };

    for (let mut y=0; y<height; ++y) {
        for (let mut x=0; x<width; ++x) {
            let ref =
                b * arr[clamp(x + 0, 0, width) + clamp(y - 1, 0, height)*width] +
                b * arr[clamp(x - 1, 0, width) + clamp(y + 0, 0, height)*width] +
                a * arr[clamp(x + 0, 0, width) + clamp(y + 0, 0, height)*width] +
                b * arr[clamp(x + 1, 0, width) + clamp(y + 0, 0, height)*width] +
                b * arr[clamp(x + 0, 0, width) + clamp(y + 1, 0, height)*width];
            let mut diff = ref - out[x + y*width];
            if (diff < 0.0f) diff = -diff;
            if (diff > 0.01f) passed++;
        }
    }

    free_array(arr);
    free_array(out);

    return passed;
}
