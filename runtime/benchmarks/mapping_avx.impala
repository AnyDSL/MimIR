fn iteration(width : int, height : int,
             arr : [float], out : [float],
             body : fn(int, int, [float], [float]) -> void
            ) -> void {
    let L = 8;
    getMicroTime();
    $iterate(0, height, |y: int| -> void {
        vectorized(width, L, || -> void {
            let x = wfv_get_tid();
            body(x, y, arr, out);
        });
    });
    getMicroTime();
}

fn iteration_bounds(width : int, height : int, ksize : int,
                    arr : [float], out : [float],
                    body : fn(int, int, [float], [float], int) -> void
                   ) -> void {
    let L = 8;

    // compute the number of vector strides for boundary handling
    let bhy = ksize / 2;
    let mut bhx = ksize / 2;
    if (bhx % L == 0) bhx = bhx / L;
    else bhx = bhx / L + L;

    // (minx, maxx, miny, maxy)
    let Bounds2D = [
        (0          , bhx        , 0           , bhy),
        (bhx        , width - bhx, 0           , bhy),
        (width - bhx, width      , 0           , bhy),

        (0          , bhx        , bhy         , height - bhy),
        (bhx        , width - bhx, bhy         , height - bhy),
        (width - bhx, width      , bhy         , height - bhy),

        (0          , bhx        , height - bhy, height),
        (bhx        , width - bhx, height - bhy, height),
        (width - bhx, width      , height - bhy, height)
    ];

    getMicroTime();
    iterate(0, 9, |region : int| -> void {
        let bounds = Bounds2D[region];
        let dim = (bounds[1] - bounds[0], bounds[3] - bounds[2], 1);

        $iterate(bounds[2], bounds[3], |y: int| -> void {
            vectorized(bounds[1]-bounds[0], L, || -> void {
                let x = wfv_get_tid();
                body(x, y, arr, out, region);
            });
        });
    });
    getMicroTime();
}

fn iteration_sep(width : int, height : int,
                 arr : [float], out : [float],
                 body_col : fn(int, int, [float], [float]) -> void,
                 body_row : fn(int, int, [float], [float]) -> void
                ) -> void {
    // allocate temporary array
    let mut tmp = array(4, width, height);
    init_zero(tmp, $width, $height);

    getMicroTime();
    $iterate(0, height, |y: int| -> void {
        $iterate(0, width, |x: int| -> void {
            body_col(x, y, arr, tmp);
        });
    });

    $iterate(0, height, |y: int| -> void {
        $iterate(0, width, |x: int| -> void {
            body_row(x, y, tmp, out);
        });
    });
    getMicroTime();

    free_array(tmp);
}

fn iteration_sep_advanced(width : int, height : int,
                          arr : [float], out : [float],
                          body_col : fn(int, int, [float], [float]) -> void,
                          body_row : fn(int, int, [float], [float]) -> void
                         ) -> void {
    let tmp = array(4, width, 1);

    getMicroTime();
    $iterate(1, height-1, |y: int| -> void {
        $iterate(0, width, |x: int| -> void {
            body_col(x, y, arr, tmp);
        });
        $iterate(0, width, |x: int| -> void {
            body_row(x, y, tmp, out);
        });
    });
    getMicroTime();

    free_array(tmp);
}
