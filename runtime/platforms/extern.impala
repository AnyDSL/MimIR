extern array(int, int, int) -> [float];
extern free_array([float]) -> void;
extern random_val(int) -> float;

extern map([float], int, int, (int, int, int), (int, int, int)) -> [float];
extern unmap([float], int, int) -> void;

extern cuda(int, (int, int, int), (int, int, int), fn() -> void) -> void;
extern nvvm(int, (int, int, int), (int, int, int), fn() -> void) -> void;
extern spir(int, (int, int, int), (int, int, int), fn() -> void) -> void;
extern vectorized(int, int, fn() -> void) -> int;
extern wfv_get_tid() -> int;
extern opencl(int, (int, int, int), (int, int, int), fn() -> void) -> void;
extern int64_to_int32(int64) -> int32;

extern getMicroTime() -> void;
extern reset_and_start_timer() -> void;
extern print_time() -> void;

fn iterate(a : int, b : int, yield : fn(int, fn())) -> void {
    let mut i: int = a;
    while (i < b)
        yield(i++, || { continue; });
}

fn force_unroll(a : int, b : int, yield : fn(int, fn())) -> void {
    if (a < b) {
        yield(a);
        @force_unroll(a+1, b, yield);
    }
}

fn iterate_times_two(a : int, b : int, yield : fn(int, fn())) -> void {
    let mut i: int = a;
    while (i < b)
        yield(i*=2, || { continue; });
}

fn init_zero(arr : [float], width : int, height : int) -> void {
    iterate(0, width*height, |i: int| -> void {
        arr[i] = 0.0f;
    });
}
fn init_rand(arr : [float], width : int, height : int) -> void {
    iterate(0, height, |y: int| -> void {
        iterate(0, width, |x: int| -> void {
            arr[x + y*width] = random_val(1024);
        });
    });
}

// border handling specialization
fn clamp_lower(idx : int, lower : int) -> int {
    return idx < lower ? lower : idx;
}
fn clamp_upper(idx : int, upper : int) -> int {
    return idx >= upper ? upper - 1 : idx;
}
fn clamp_none(idx : int, bound : int) -> int {
    return idx;
}
