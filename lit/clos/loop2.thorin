
.import mem;
.import core;

.let i32 = %Int 4294967296;
.let i8 = %Int 256;

.cn outer [mem: %mem.M, x : i32, return : .Cn [%mem.M, i32]] = {
    .cn loop_body [mem: %mem.M, i : i32, continue : .Cn %mem.M] = {
       continue(mem)
    };

    .cn loop_head [mem: %mem.M, i : i32] = {
        .cn exit [mem: %mem.M] = {
            return (mem, i)
        };

        .cn yield [mem: %mem.M] = {
            loop_head( mem, %core.wrap.add (0, 4294967296) (i, 1:i32) )
        };

        .cn enter [mem: %mem.M] = {
            loop_body ( mem, i, yield )
        };

        .let condition = %core.icmp.ul 4294967296 (i, 19:i32);
        .let target = (exit, enter)#condition;
        target ( mem )
    };

    loop_head ( mem, 3:i32 )
};

.cn .extern main [mem: %mem.M, argc: i32, argv : %mem.Ptr («⊤:.Nat; %mem.Ptr («⊤:.Nat; %Int 256», 0:.Nat)», 0:.Nat), return : .Cn [%mem.M, i32]] = {
    .cn callback (mem: %mem.M, x : i32) = {
        return (mem, x)
    };

    outer(mem, 1:i32, callback)
};
