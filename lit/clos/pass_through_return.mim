// RUN: rm -f %t.ll
// RUN: %mim -p clos %s --output-ll %t.ll -o -

plugin core;
plugin direct;

let pb_type = Cn [%mem.M 0, Cn [%mem.M 0]];

fun end_(mem: %mem.M 0): %mem.M 0 = return mem;

ccon printInteger [mem: %mem.M 0, val: I32, return : Cn [%mem.M 0]];

con extern main [mem: %mem.M 0, argc: I32, argv : %mem.Ptr («⊤:Nat; %mem.Ptr («⊤:Nat; I8», 0)», 0), return : Cn [%mem.M 0, I32]] =
    con callback (mem: %mem.M 0) = return (mem, 1I32);

    let (alloc_pb_mem, pb_ptr) = %mem.malloc (pb_type, 0) (mem, 100);
    let pb_arr = %core.bitcast (%mem.Ptr («⊤:Nat; pb_type», 0)) pb_ptr;
    let lea_pb = %mem.lea (pb_arr, 0I32);
    let store_pb = %mem.store (alloc_pb_mem, lea_pb, end_);

    con loop_head [mem: %mem.M 0, i : I32] =
        con exit [mem: %mem.M 0] =
            let (backward_pass_mem, backward_pass) = %mem.load (mem, lea_pb); // <- begin backward pass
            backward_pass (backward_pass_mem, callback);

        con yield [mem: %mem.M 0] = loop_head( mem, %core.wrap.add 0 (i, 1I32) );

        con body [mem: %mem.M 0] =
            let (load_pb_mem, last_pb) = %mem.load (mem, lea_pb);
            con pb [mem: %mem.M 0, end_: Cn [%mem.M 0]] =
                con inner_yield [mem: %mem.M 0] = last_pb (mem, end_);
                printInteger(mem, i, inner_yield);
                //last_pb (mem, end_)  // << call previous backward pass block

            let store_pb_mem = %mem.store (load_pb_mem, lea_pb, pb); // << stack backward pass block

            printInteger(store_pb_mem, i, yield);

        let condition = %core.icmp.ul (i, 19I32);
        let target = (exit, body)#condition;
        target ( mem );

    loop_head ( store_pb, 0I32 ); // <-- start forward pass
