// RUN: rm -f %t.ll
// RUN: %thorin -p clos %s --output-ll %t.ll -o -

.plugin core;

.let void_ptr = %mem.Ptr («⊤:.Nat; []», 0);

.con printInteger [mem: %mem.M, val: %core.I32, return : .Cn [%mem.M]];
.con printNL [mem: %mem.M, return : .Cn [%mem.M]];
.con time [mem: %mem.M, return : .Cn [%mem.M, void_ptr]];
.con print_time_diff [mem: %mem.M, t1: void_ptr, t2: void_ptr, return : .Cn [%mem.M]];

.let size = 100000;

.con printArr [mem: %mem.M, arr : %mem.Ptr (<<size; %core.I32>>, 0), return : .Cn [%mem.M]] = {
    .let arr_size = ⊤:.Nat;

    .con loop_body [mem: %mem.M, i : %core.I32, continue : .Cn %mem.M] = {
        .let lea = %mem.lea_unsafe (arr, i);
        .let (load_mem, val) = %mem.load (mem, lea);
        printInteger(load_mem, val, continue)
    };

    .con loop_head [mem: %mem.M, i : %core.I32] = {
        .con yield [mem: %mem.M] = {
            loop_head( mem, %core.wrap.add 0 (i, 1:%core.I32) )
        };

        .con enter [mem: %mem.M] = {
            loop_body ( mem, i, yield )
        };

        .con exit [mem: %mem.M] = {
            printNL (mem, return)
        };

        .let condition = %core.icmp.ul (i, %core.bitcast %core.I32 size);
        .let target = (exit, enter)#condition;
        target ( mem )
    };

    loop_head ( mem, 0:%core.I32 )
};

.con init [mem: %mem.M, arr : %mem.Ptr (<<size; %core.I32>>, 0), offset : %core.I32, return : .Cn [%mem.M]] = {
    .let arr_size = ⊤:.Nat;

    .con loop_body [mem: %mem.M, i : %core.I32, continue : .Cn %mem.M] = {
        .let lea = %mem.lea_unsafe (arr, i);
        .let add = %core.wrap.add 0 (offset, i);
        .let store_mem = %mem.store (mem, lea, add);
        continue(store_mem)
    };

    .con loop_head [mem: %mem.M, i : %core.I32] = {
        .con yield [mem: %mem.M] = {
            loop_head( mem, %core.wrap.add 0 (i, 1:%core.I32) )
        };

        .con enter [mem: %mem.M] = {
            loop_body ( mem, i, yield )
        };

        .let condition = %core.icmp.ul (i, %core.bitcast %core.I32 size);
        .let target = (return, enter)#condition;
        target ( mem )
    };

    loop_head ( mem, 0:%core.I32 )
};


.con const [mem: %mem.M, arr : %mem.Ptr (<<size; %core.I32>>, 0), constValue : %core.I32, return : .Cn [%mem.M]] = {
    .let arr_size = ⊤:.Nat;

    .con loop_body [mem: %mem.M, i : %core.I32, continue : .Cn %mem.M] = {
        .let lea = %mem.lea_unsafe (arr, i);

        .let store_mem = %mem.store (mem, lea, constValue);
        continue(store_mem)
    };

    .con loop_head [mem: %mem.M, i : %core.I32] = {
        .con yield [mem: %mem.M] = {
            loop_head( mem, %core.wrap.add 0 (i, 1:%core.I32) )
        };

        .con enter [mem: %mem.M] = {
            loop_body ( mem, i, yield )
        };

        .let condition = %core.icmp.ul (i, %core.bitcast %core.I32 size);
        .let target = (return, enter)#condition;
        target ( mem )
    };

    loop_head ( mem, 0:%core.I32 )
};


.con outer [mem: %mem.M, x : %core.I32, return : .Cn [%mem.M]] = {

    .let arr_size = ⊤:.Nat;

    .let (alloc_mem_a, a_arr) = %mem.alloc (<<size; %core.I32>>, 0) (mem);
    .let (alloc_mem_b, b_arr) = %mem.alloc (<<size; %core.I32>>, 0) (alloc_mem_a);
    .let (alloc_mem_c, c_arr) = %mem.alloc (<<size; %core.I32>>, 0) (alloc_mem_b);

    .let (alloc_mem_ad, ad_arr) = %mem.alloc (<<size; %core.I32>>, 0) (alloc_mem_c);
    .let (alloc_mem_bd, bd_arr) = %mem.alloc (<<size; %core.I32>>, 0) (alloc_mem_ad);
    .let (alloc_mem_cd, cd_arr) = %mem.alloc (<<size; %core.I32>>, 0) (alloc_mem_bd);

    .let pb_type = .Cn [%mem.M, %core.I32, .Cn [%mem.M]];
    .let (alloc_pb_mem, pb_ptr) = %mem.alloc (<<size; pb_type>>, 0) (alloc_mem_cd);
    .let pb_arr = %core.bitcast (%mem.Ptr («⊤:.Nat; pb_type», 0)) pb_ptr;
    .let finish_mem = alloc_pb_mem;

    .con loop_body [mem: %mem.M, i : %core.I32, return : .Cn %mem.M] = {
        .let a_lea = %mem.lea_unsafe (a_arr, i);
        .let b_lea = %mem.lea_unsafe (b_arr, i);
        .let c_lea = %mem.lea_unsafe (c_arr, i);

        .let (a_load_mem, a_val) = %mem.load (mem, a_lea);
        .let (b_load_mem, b_val) = %mem.load (a_load_mem, b_lea);

        .let prod = %core.wrap.mul 0 (a_val, b_val);

        .let c_store_mem = %mem.store (b_load_mem, c_lea, prod);

        .con left_pb [mem: %mem.M, s : %core.I32, return: .Cn [%mem.M]] = {
            .let ad_lea = %mem.lea_unsafe (ad_arr, i);
            .let (load_mem, val) = %mem.load (mem, ad_lea);
            .let new_val = %core.wrap.add 0 (val, s);
            .let store_mem = %mem.store (load_mem, ad_lea, new_val);
            return store_mem
        };

        .con right_pb [mem: %mem.M, s : %core.I32, return: .Cn [%mem.M]] = {
            .let bd_lea = %mem.lea_unsafe (bd_arr, i);
            .let (load_mem, val) = %mem.load (mem, bd_lea);
            .let new_val = %core.wrap.add 0 (val, s);
            .let store_mem = %mem.store (load_mem, bd_lea, new_val);
            return store_mem
        };

        .con mul_pb [mem: %mem.M, s : %core.I32, return: .Cn [%mem.M]] = {
            .let sa_mul = %core.wrap.mul 0 (s, b_val);

            .con next [mem: %mem.M] = {
                .let sb_mul = %core.wrap.mul 0 (s, a_val);
                right_pb(mem, sb_mul, return)
            };

            left_pb( mem, sa_mul,  next)
        };

        .let lea_pb = %mem.lea_unsafe (pb_arr, i);
        .let store_pb_mem = %mem.store (c_store_mem, lea_pb, mul_pb);

        return(store_pb_mem)
    };


    .con print_c [mem: %mem.M] = {
        printArr(mem, c_arr, return)
    };

    .con print_b [mem: %mem.M] = {
        printArr(mem, b_arr, print_c)
    };

    .con print_a [mem: %mem.M] = {
        printArr(mem, a_arr, print_b)
    };

    .con print_cd [mem: %mem.M] = {
        printArr(mem, cd_arr, print_a)
    };

     .con print_bd [mem: %mem.M] = {
        printArr(mem, bd_arr, print_cd)
    };

    .con print_ad [mem: %mem.M] = {
        printArr(mem, ad_arr, print_bd)
    };



    .con time_start_cont [mem:%mem.M, start_time:void_ptr] = {

        .con timer [mem:%mem.M] = {
            .con time_end_cont [mem:%mem.M, end_time:void_ptr] = {
                print_time_diff (mem, start_time, end_time, print_ad)
            };
            time (mem, time_end_cont)
            // print_ad(mem)
        };

        .con backward_loop_head [mem: %mem.M, i : %core.I32] = {
            .con yield [mem: %mem.M] = {
                backward_loop_head( mem, %core.wrap.add 0 (i, 1:%core.I32) )
            };

            .con enter [mem: %mem.M] = {
                .let lea_pb = %mem.lea_unsafe (pb_arr, i);
                .let (backward_pass_mem, backward_pass) = %mem.load (mem, lea_pb);
                backward_pass ( backward_pass_mem, 1:%core.I32, yield )
            };

            .let condition = %core.icmp.ul (i, %core.bitcast %core.I32 size);
            .let target = (timer, enter)#condition;
            target ( mem )
        };


        .con loop_head [mem: %mem.M, i : %core.I32] = {
            .con exit [mem: %mem.M] = {
                backward_loop_head(mem, 0:%core.I32)
            };

            .con yield [mem: %mem.M] = {
                loop_head( mem, %core.wrap.add 0 (i, 1:%core.I32) )
            };

            .con enter [mem: %mem.M] = {
                loop_body ( mem, i, yield )
            };

            .let condition = %core.icmp.ul (i, %core.bitcast %core.I32 size);
            .let target = (exit, enter)#condition;
            target ( mem )
        };
        loop_head ( mem, 0:%core.I32 )
    };

    .con init_a [mem: %mem.M] = {
        .con init_b [mem: %mem.M] = {
            .con init_c [mem: %mem.M] = {
                .con init_ad [mem: %mem.M] = {
                    .con init_bd [mem: %mem.M] = {
                        .con init_cd [mem: %mem.M] = {
                            time (mem, time_start_cont)
                            // loop_head ( mem, 0:%core.I32 )
                        };

                        const(mem, cd_arr, 1:%core.I32, init_cd)
                    };

                    const(mem, bd_arr,  0:%core.I32, init_bd)
                };

                const(mem, ad_arr,  0:%core.I32, init_ad)
            };

            const(mem, c_arr, 0:%core.I32, init_c)
        };

        init(mem, b_arr, 1:%core.I32, init_b)
    };

    init(finish_mem, a_arr, 0:%core.I32, init_a)
};

.con .extern main [mem: %mem.M, argc: %core.I32, argv : %mem.Ptr («⊤:.Nat; %mem.Ptr («⊤:.Nat; %core.I8», 0)», 0), return : .Cn [%mem.M, %core.I32]] = {
    .con callback (mem: %mem.M) = {
        return (mem, 1:%core.I32)
    };

    outer(mem, 1:%core.I32, callback)
};
