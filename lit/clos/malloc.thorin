// RUN: rm -f %t.ll ; \
// RUN: %thorin -p clos %s --output-ll %t.ll -o - 

.plugin core;

.let I32 = .Idx 4294967296;

.con f [mem: %mem.M, x: I32, return: .Cn [%mem.M, I32]] = {
    return (mem, %core.wrap.add 0 (x, 42:I32))
};

.con g [mem: %mem.M, x: I32, return: .Cn [%mem.M, I32]] = {
    return (mem, 1:I32)
};


.con .extern main [mem: %mem.M, argc: I32, argv: %mem.Ptr («⊤:.Nat; %mem.Ptr («⊤:.Nat; .Idx 256», 0)», 0), return: .Cn [%mem.M, I32]] = {
    .con h(mem: %mem.M, x: I32, return: .Cn [%mem.M, I32]) = return (mem, %core.wrap.add 0 (x, argc));

    .let pb_type  = .Cn [%mem.M, I32, .Cn [%mem.M, I32]];
    .let Tas      = (pb_type, 0);
    .let arr_size = ⊤:.Nat;

    .let ('mem, pb_ptr) = %mem.malloc Tas (mem, 32);
    .let pb_arr         = %core.bitcast (%mem.Ptr («⊤:.Nat; .Cn [%mem.M, I32, .Cn [%mem.M, I32]]», 0)) pb_ptr;
    .let ('mem, a_arr)  = %mem.alloc (<<4; I32>>, 0) (mem);

    .let 'lea = %mem.lea (arr_size, <arr_size; pb_type>, 0) (pb_arr, 0:I32);
    .let 'mem = %mem.store (mem, lea, f);
    .let 'lea = %mem.lea (arr_size, <arr_size; pb_type>, 0) (pb_arr, 1:I32);
    .let 'mem = %mem.store (mem, lea, g);
    .let 'lea = %mem.lea (arr_size, <arr_size; pb_type>, 0) (pb_arr, 2:I32);
    .let 'mem = %mem.store (mem, lea, h);
    .let 'lea = %mem.lea (arr_size, <arr_size; I32>, 0) (a_arr, 0:I32);
    .let 'mem = %mem.store (mem, lea, 10:I32);
    .let 'lea = %mem.lea (arr_size, <arr_size; pb_type>, 0) (pb_arr, 2:I32);
    .let ('mem, func) = %mem.load (mem, lea);
    .let ('mem,  val) = %mem.load (load_mem, lea);

    .con callback (mem: %mem.M, x: I32) = return (mem, x);

    func(mem, 1:I32, callback)
};
