// RUN: rm -f %t.ll ; \
// RUN: %thorin -d autodiff %s --output-ll %t.ll --output-thorin - | FileCheck %s

.import core;
.import autodiff;
.import mem;

.let I32 = .Idx 4294967296;

.cn f [[mem : %mem.M, x: I32], ret: .Cn [mem : %mem.M, I32]] = {
    .let (alloc_mem, a) = %mem.alloc («100:.Nat; I32», 0) mem;
    .let lea1 = %mem.lea (100:.Nat, <100:.Nat; I32>, 0) (a, 1:(.Idx 100));
    .let store_mem = %mem.store (I32, 0) (alloc_mem, lea1, x);

    .let lea = %mem.lea (100:.Nat, <100:.Nat; I32>, 0) (a, 1:(.Idx 100));
    .let (load_mem, load_val) = %mem.load (I32, 0) (store_mem, lea);
    .let scaled = %core.wrap.mul (0:.Nat, 4294967296:.Nat) (100:I32, load_val);
    ret (load_mem, scaled)
};

.cn .extern main [mem : %mem.M, argc : I32, argv : %mem.Ptr (%mem.Ptr (.Idx 256, 0:.Nat), 0:.Nat), return : .Cn [%mem.M, I32]] = {

    .cn ret_cont [[mem : %mem.M, a: I32], pb:.Cn[[%mem.M, I32],.Cn[[%mem.M, I32]]]] = {
        .cn pb_ret_cont [mem : %mem.M, x: I32] = {
            // .let lea = %mem.lea (100:.Nat, <100:.Nat; I32>, 0) (a, 1:(.Idx 100));
            // .let (load_mem, load_val) = %mem.load (I32, 0) (mem, lea);
            // return (load_mem, load_val)
            return (mem, x)
            // return (mem, (a,x))
        };
        pb((mem, 1:I32), pb_ret_cont)
    };


    .let f_diff = %autodiff.ad (.Cn [[%mem.M, I32],.Cn[%mem.M, I32]]) f;

    f_diff ((mem, argc),ret_cont)
};



// CHECK-DAG: .cn .extern main _{{[0-9_]+}}::[mem_[[memId:[_0-9]*]]: %mem.M, (I32), %mem.Ptr (%mem.Ptr ((.Idx 256), 0:.Nat), 0:.Nat), return_[[returnId:[_0-9]*]]: .Cn [%mem.M, (I32)]] = {
// CHECK-DAG: _[[appId:[_0-9]*]]: ⊥:★ = return_[[returnEtaId:[_0-9]*]] (mem_[[memId]], 42:(I32));
// CHECK-DAG: _[[appId]]

// CHECK-DAG: return_[[returnEtaId]] _[[returnEtaVarId:[0-9_]+]]: [%mem.M, (I32)] = {
// CHECK-DAG: return_[[retAppId:[_0-9]*]]: ⊥:★ = return_[[returnId]] _[[returnEtaVarId]];
// CHECK-DAG: return_[[retAppId]]
