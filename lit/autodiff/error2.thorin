
.import mem;
.import core;
.import direct;

.let i32 = .Idx 4294967296;
.let i8 = .Idx 256;

.cn printIntegerA [mem: %mem.M, val: i32, return : .Cn [%mem.M]];
.cn printIntegerB [mem: %mem.M, val: i32, return : .Cn [%mem.M]];

.cn .extern main [mem: %mem.M, argc: i32, argv : %mem.Ptr («⊤:.Nat; %mem.Ptr («⊤:.Nat; .Idx 256», 0:.Nat)», 0:.Nat), return : .Cn [%mem.M, i32]] = {
    .cn exit [mem: %mem.M] = {
        return (mem, 1:i32)
    };

    .let (alloc_mem, ptr) = %mem.alloc («100:.Nat; i32», 0) mem;

    .cn loop_head [mem: %mem.M, i : i32] = {
        .cn body [mem: %mem.M] = {
            .let lea = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (ptr, 0:(.Idx 100));
            .let (load_mem, value) = %mem.load (i32, 0) (mem, lea);
            loop_head( load_mem, %core.wrap.add (0, 4294967296) (i, 1:i32) )
        };

        .let condition = %core.icmp.ul 4294967296 (i, 10:i32);
        .let target = (exit, body)#condition;
        target ( mem )
    };

    loop_head ( alloc_mem, 0:i32 )
};
