// RUN: rm -f %t.ll ; \
// RUN: %thorin -d autodiff %s --output-ll %t.ll --output-thorin - | FileCheck %s

// a call to a autodiff style function
// ./build/bin/thorin -d debug -d direct -d autodiff ./lit/autodiff/multiply_autodiff.thorin --output-thorin - -VVVV

.import core;
.import autodiff;
.import mem;
.import affine;

.let i32 = .Idx 4294967296;
.let size = 100:.Nat;
.let size_idx = (.Idx 100);
.let size_int = 100:i32;
.let arr_size = <<size; i32>>;
.let ptr_ty = %mem.Ptr (arr_size, 0);

.cn printInteger [mem: %mem.M, val: i32, return : .Cn [%mem.M]];

.cn f [mem : %mem.M, a: ptr_ty, ret: .Cn [ %mem.M, i32]] = {
    .let lea_a = %mem.lea (size, <size; i32>, 0) (a, 0:(.Idx 100));
    .let lea_b = %mem.lea (size, <size; i32>, 0) (a, 1:(.Idx 100));
    .let (load_mem, load_val) = %mem.load (i32, 0) (mem, lea_a);
    .let store_mem = %mem.store (i32, 0) (load_mem, lea_b, load_val);
    ret (store_mem, 0:i32)
};

.cn init [mem: %mem.M, ptr : ptr_ty, offset : i32, ret : .Cn [%mem.M]] = {
    .cn for_exit [mem : %mem.M] = {
        ret (mem)
    };

    .cn for_body [i : i32, mem : %mem.M, continue : .Cn [%mem.M]] = {
        .let idx_100_i = %core.bitcast (size_idx, i32) i;
        .let lea = %mem.lea (size, <size; i32>, 0) (ptr, idx_100_i);

        .let sum = %core.wrap.add (0:.Nat, 4294967296:.Nat) (offset, i);
        .let store_mem = %mem.store (i32, 0) (mem, lea, sum);
        continue (store_mem)
    };

    %affine.For (4294967296, 1, (%mem.M)) (0:i32, size_int, 1:i32, (mem), for_body, for_exit)
};

.cn const [mem: %mem.M, ptr : ptr_ty, value : i32, ret : .Cn [%mem.M]] = {
    .cn for_exit [mem : %mem.M] = {
        ret (mem)
    };

    .cn for_body [i : i32, mem : %mem.M, continue : .Cn [%mem.M]] = {
        .let idx_100_i = %core.bitcast (size_idx, i32) i;
        .let lea = %mem.lea (size, <size; i32>, 0) (ptr, idx_100_i);
        .let store_mem = %mem.store (i32, 0) (mem, lea, value);
        continue (store_mem)
    };

    %affine.For (4294967296, 1, (%mem.M)) (0:i32, size_int, 1:i32, (mem), for_body, for_exit)
};

.cn .extern main [mem : %mem.M, argc : i32, argv : %mem.Ptr (%mem.Ptr (.Idx 256, 0:.Nat), 0:.Nat), return : .Cn [%mem.M, i32]] = {

    .let (alloc_a_mem, a) = %mem.alloc (arr_size, 0) mem;
    .let (alloc_ad_mem, ad) = %mem.alloc (arr_size, 0) alloc_a_mem;

    .let lea_ad0 = %mem.lea (size, <size; i32>, 0) (ad, 0:(.Idx 100));
    .let lea_ad1 = %mem.lea (size, <size; i32>, 0) (ad, 1:(.Idx 100));
    .let lea_a0 = %mem.lea (size, <size; i32>, 0) (a, 0:(.Idx 100));
    .let lea_a1 = %mem.lea (size, <size; i32>, 0) (a, 1:(.Idx 100));

    .cn ret_cont [mem : %mem.M, result: i32, pb:.Cn[%mem.M, ptr_ty, s: i32, .Cn[%mem.M, ptr_ty]]] = {
        .cn pb_ret_cont [mem : %mem.M, ad: ptr_ty] = {
            .cn finish [mem : %mem.M] = {

                .let (mem2, load_val_ad0) = %mem.load (i32, 0) (mem, lea_ad0);
                .let (mem3, load_val_ad1) = %mem.load (i32, 0) (mem2, lea_ad1);
                .let (mem4, load_val_a0) = %mem.load (i32, 0) (mem, lea_a0);
                .let (mem5, load_val_a1) = %mem.load (i32, 0) (mem2, lea_a1);

                .let free_mem = %mem.free (arr_size, 0) (mem3, a);
                .let free_mem2 = %mem.free (arr_size, 0) (free_mem, ad);

                .cn print_ret4 [mem : %mem.M] = {
                    return (mem, 0:i32)
                };

                .cn print_ret3 [mem : %mem.M] = {
                    printInteger ( mem, load_val_ad1, print_ret4 )
                };

                .cn print_ret2 [mem : %mem.M] = {
                    printInteger ( mem, load_val_ad0, print_ret3 )
                };

                .cn print_ret1 [mem : %mem.M] = {
                    printInteger ( mem, load_val_a1, print_ret2 )
                };

                printInteger ( mem, load_val_a0, print_ret1 )
            };

            finish ( mem )
        };

        pb(mem, ad, 0:i32, pb_ret_cont)
    };

    .let f_diff = %autodiff.ad (.Cn [%mem.M, ptr_ty,.Cn[%mem.M, i32]]) f;

    .cn enter_diff [mem : %mem.M] = {
        f_diff (mem, a,ret_cont)
    };

    .cn init_test [mem : %mem.M] = {
        .let store_mem = %mem.store (i32, 0) (mem, lea_ad0, 11:i32);
        .let store_mem2 = %mem.store (i32, 0) (store_mem, lea_a0, 22:i32);
        .let store_mem3 = %mem.store (i32, 0) (store_mem2, lea_a1, 33:i32);
        enter_diff store_mem3
    };

    .cn init_ad [mem : %mem.M] = {
        const(mem, ad, 0:i32, init_test)
    };

    .cn init_a [mem : %mem.M] = {
        init(mem, a, 1:i32, init_ad)
    };

    init_a ( alloc_ad_mem )
};



// CHECK-DAG: .cn .extern main _{{[0-9_]+}}::[mem_[[memId:[_0-9]*]]: %mem.M, (i32), %mem.Ptr (%mem.Ptr ((.Idx 256), 0:.Nat), 0:.Nat), return_[[returnId:[_0-9]*]]: .Cn [%mem.M, (i32)]] = {
// CHECK-DAG: _[[appId:[_0-9]*]]: ⊥:★ = return_[[returnEtaId:[_0-9]*]] (mem_[[memId]], 42:(i32));
// CHECK-DAG: _[[appId]]

// CHECK-DAG: return_[[returnEtaId]] _[[returnEtaVarId:[0-9_]+]]: [%mem.M, (i32)] = {
// CHECK-DAG: return_[[retAppId:[_0-9]*]]: ⊥:★ = return_[[returnId]] _[[returnEtaVarId]];
// CHECK-DAG: return_[[retAppId]]
