// RUN: rm -f %t.ll ; \
// RUN: %thorin -d autodiff %s --output-ll %t.ll --output-thorin - | FileCheck %s

// a call to a autodiff style function
// ./build/bin/thorin -d debug -d direct -d autodiff ./lit/autodiff/multiply_autodiff.thorin --output-thorin - -VVVV

.import core;
.import autodiff;
.import mem;
.import affine;

.let i32 = .Idx 4294967296;

.cn printInteger [mem: %mem.M, val: i32, return : .Cn [%mem.M]];

.cn f [[mem : %mem.M, a: %mem.Ptr («100:.Nat; i32», 0), b: %mem.Ptr («100:.Nat; i32», 0)], ret: .Cn [mem : %mem.M, i32]] = {
    .cn for_exit acc :: [mem : %mem.M, i32, i32] = {
        .let lea = %mem.lea (arr_size, <arr_size; i32>, 0) (ptr, %core.conv.u2u (arr_size, 4294967296) (%core.wrap.sub (0, 4294967296) (argc, 4:i32)));
        .let (load_mem, val) = %mem.load (i32, 0) (mem, lea);
        ret (load_mem2, scaled)
    };

    .cn for_body [i : i32, [mem : %mem.M, acc: i32], continue : .Cn [%mem.M]] = {
        .let lea1 = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (a, i);
        .let lea2 = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (a, i);
        .let (load_mem1, load_val1) = %mem.load (i32, 0) (mem, lea1);
        .let (load_mem2, load_val2) = %mem.load (i32, 0) (load_mem1, lea2);
        .let scaled = %core.wrap.mul (0:.Nat, 4294967296:.Nat) (load_val1, load_val2);
        continue (load_mem2, scaled)
    };

    %affine.For (4294967296, 3, (%mem.M)) (0:(.Idx 100), 100:(.Idx 100), 1:(.Idx 100), (alloc_mem, 0:i32), for_body, for_exit)
};

.cn .extern main [mem : %mem.M, argc : i32, argv : %mem.Ptr (%mem.Ptr (.Idx 256, 0:.Nat), 0:.Nat), return : .Cn [%mem.M, i32]] = {

    .cn ret_cont [[mem : %mem.M, a: i32], pb:.Cn[[%mem.M, i32],.Cn[[%mem.M, %mem.Ptr («100:.Nat; i32», 0)]]]] = {
        .cn pb_ret_cont [mem : %mem.M, a: %mem.Ptr («100:.Nat; i32», 0)] = {
            .let lea1 = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (a, 0:(.Idx 100));

            .let (load_mem1, load_val) = %mem.load (i32, 0) (mem, lea1);

            .cn print_integer_callback2 [mem : %mem.M] = {
                .let free_mem = %mem.free («100:.Nat; i32», 0) (mem, a);
                return (free_mem, 0:i32)
            };

            .cn print_integer_callback [mem : %mem.M] = {
                .let lea2 = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (a, 1:(.Idx 100));
                .let (load_mem2, load_val) = %mem.load (i32, 0) (load_mem1, lea2);
                printInteger ( load_mem2, load_val, print_integer_callback2 )
            };

            printInteger ( load_mem1, load_val, print_integer_callback )
        };
        pb((mem, 1:i32), pb_ret_cont)
    };

    .let (alloc_mem, alloc_val) = %mem.alloc («100:.Nat; i32», 0) mem;

    .let lea1 = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (alloc_val, 0:(.Idx 100));
    .let lea2 = %mem.lea (100:.Nat, <100:.Nat; i32>, 0) (alloc_val, 1:(.Idx 100));
    .let store_mem = %mem.store (i32, 0) (alloc_mem, lea1, 11:i32);
    .let store_mem2 = %mem.store (i32, 0) (store_mem, lea2, 42:i32);

    .let f_diff = %autodiff.autodiff (.Cn [[%mem.M, %mem.Ptr («100:.Nat; i32», 0)],.Cn[%mem.M, i32]]) f;

    f_diff ((store_mem2, alloc_val),ret_cont)
};



// CHECK-DAG: .cn .extern main _{{[0-9_]+}}::[mem_[[memId:[_0-9]*]]: %mem.M, (i32), %mem.Ptr (%mem.Ptr ((.Idx 256), 0:.Nat), 0:.Nat), return_[[returnId:[_0-9]*]]: .Cn [%mem.M, (i32)]] = {
// CHECK-DAG: _[[appId:[_0-9]*]]: ⊥:★ = return_[[returnEtaId:[_0-9]*]] (mem_[[memId]], 42:(i32));
// CHECK-DAG: _[[appId]]

// CHECK-DAG: return_[[returnEtaId]] _[[returnEtaVarId:[0-9_]+]]: [%mem.M, (i32)] = {
// CHECK-DAG: return_[[retAppId:[_0-9]*]]: ⊥:★ = return_[[returnId]] _[[returnEtaVarId]];
// CHECK-DAG: return_[[retAppId]]
