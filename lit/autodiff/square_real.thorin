// RUN: rm -f %t.ll ; \
// RUN: %thorin -d direct -d autodiff -d math %s --output-ll %t.ll --output-thorin - | FileCheck %s

.import core;
.import autodiff;
.import mem;
.import math;

.let _32 = 4294967296;
.let I32 = .Idx _32;
.let f32 = (23,  8);
.let f64 = (52, 11);
.let F32 = %math.F f32;
.let F64 = %math.F f64;


.lam .extern internal_diff_math_arith_mul
    ![p:.Nat, e:.Nat] -> 
    ([.Nat] -> 
    (.Cn[[%math.F (p, e), %math.F (p, e)], .Cn[%math.F (p, e), .Cn[%math.F (p, e), .Cn[%math.F (p, e), %math.F (p, e)]]]]))
    = { 
    .lam wrap 
    ![mode: .Nat] -> 
    (.Cn[[%math.F (p, e), %math.F (p, e)], .Cn[%math.F (p, e), .Cn[%math.F (p, e), .Cn[%math.F (p, e), %math.F (p, e)]]]])
    = { 
        .cn inner_deriv
            ![[a:%math.F (p, e), b:%math.F (p, e)], ret:.Cn[%math.F (p, e), .Cn[%math.F (p, e), .Cn[%math.F (p, e), %math.F (p, e)]]]]@(.tt)
            = { 
            .let result = %math.arith.mul (p,e) mode (a,b);
            .cn pb ![s:(%math.F (p,e)), pb_ret:(.Cn [%math.F (p, e), %math.F (p, e)])]@(.tt) = { 
                .let lhs = %math.arith.mul (p,e) mode (s,b);
                .let rhs = %math.arith.mul (p,e) mode (s,a);
                pb_ret (lhs, rhs)
            };
            ret (result,pb)
        };
        inner_deriv
    };
    wrap
};



.cn f [a:F64, ret: .Cn [F64]] = {
    .let b = %math.arith.mul f64 0 (a, a);
    ret b
};

.cn g [a:F64, ret: .Cn [F64, .Cn [F64, .Cn [F64]]]] = {
    .let f_diff = %autodiff.ad (.Cn [F64,.Cn[F64]]) f;
    f_diff (a,ret)
};

.cn .extern test [[], ret: .Cn [[F64,F64],[F64,F64]]] = {
    .cn inner [r:F64, pb:.Cn [F64, .Cn [F64]]] = {
        .cn pb_rec p::[F64] = {
            // We return expected result and derivative together with the real values.
            // If both are the same, the normalizer creates a pack which is tested for.
            ret ((25.0:F64,10.0:F64),(r,p))
        };
        pb (1.0:F64, pb_rec)
    };
    g (5.0:F64, inner)
};


// CHECK-DAG: ret{{.*}}‹2;{{.*}}›
