// RUN: %mim %s
plugin tensor;
plugin refly;
plugin core;
plugin direct;
plugin affine;
plugin math;


let f32 = %math.f32;
let F32 = %math.F32;

let R: Ring = (F32, 0: F32, %math.arith.add @f32 0, %math.arith.mul @f32 0);

lam F32_add {r: Nat, s: «r; Nat»} [is: [«s; F32», «s; F32»]] : «s; F32» = %tensor.binary (%math.arith.add @f32 0) is;
lam F32_sub {r: Nat, s: «r; Nat»} [is: [«s; F32», «s; F32»]] : «s; F32» = %tensor.binary (%math.arith.sub @f32 0) is;
lam F32_tanh {r: Nat, s: «r; Nat»} [i: «s; F32»] : «s; F32» = %tensor.unary (%math.tri.tanh @f32 0) i;


fun extern main [arg0: «784; «1024; F32»», arg1: «1024; F32», arg2: «1024; «1024; F32»», arg3: «1024; F32», arg4: «1024; «10; F32»», arg5: «10; F32», arg6: «128; «784; F32»», arg7: «128; «10; F32»»]
  : [«784; «1024; F32»», «1024; F32», «1024; «1024; F32»», «1024; F32», «1024; «10; F32»», «10; F32»]
  = let _0 = %tensor.prod_2d R (arg6, arg0);
    let _2 = %tensor.broadcast ((1, 1024), (128, 1024), arg1);
    let _3 = F32_add @(2, (128, 1024)) (_0, _2);
    let _4 = F32_tanh @(2, (128, 1024)) _3;
    let _5 = ‹128; ‹1024; 0:F32››;
    let _6 = F32_sub @(2, (128, 1024)) (_5, _4);
    let _7 = %tensor.prod_2d R (_4, arg2);
    let _9 = %tensor.broadcast ((1, 1024), (128, 1024), arg3);
    return (arg0, arg1, arg2, arg3, arg4, arg5);