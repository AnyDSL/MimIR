// RUN: rm -f %t.ll
// RUN: %mim %s -O 0

plugin core;
plugin gpu;

fun kernel (m1: %gpu.GlobalM, m3: %gpu.SharedM, m4: %gpu.ConstM, m5: %gpu.LocalM,
            group_id: Idx 4, item_id: Idx 4, data: %gpu.GlobalPtr «4; I32»)
         : [%gpu.GlobalM, %gpu.SharedM, %gpu.ConstM, %gpu.LocalM] =
    let el = %mem.lea (data, item_id);
    let val = %core.bitcast I32 item_id;
    let val = %core.wrap.add 0 (val, 42I32);
    let m1 = %mem.store (m1, el, val);
    return (m1, m3, m4, m5);

fun extern main (m0: %mem.M 0, m1: %gpu.GlobalM, argc: I32, argv: %mem.Ptr («⊤:Nat; %mem.Ptr («⊤:Nat; I8», 0)», 0))
              : [%mem.M 0, %gpu.GlobalM, I32] =
    let (m0, arr) = %mem.alloc («4; I32», 0) m0;

    let arr_0 = %mem.lea (arr, 0_4);
    let m0 = %mem.store (m0, arr_0, argc);
    let arr_1 = %mem.lea (arr, 1_4);
    let m0 = %mem.store (m0, arr_1, argc);
    let arr_2 = %mem.lea (arr, 2_4);
    let m0 = %mem.store (m0, arr_2, argc);
    let arr_3 = %mem.lea (arr, 3_4);
    let m0 = %mem.store (m0, arr_3, argc);

    let (m1, d_ptr) = %mem.alloc («4; I32», 1) m1;
    let (m0, m1) = %gpu.copy_to_device (m0, m1, arr, d_ptr);

    ret m0 = %gpu.launch (m0, 4, 4, %gpu.DefaultStream) kernel $ d_ptr;

    let (m0, m1) = %gpu.copy_to_host (m0, m1, d_ptr, arr);
    let m1 = %mem.free (m1, d_ptr);
    
    let idx = %core.bitcast (Idx 4) (%core.wrap.sub 0 (argc, 1I32));
    let val_arr = %mem.lea (arr, %core.bitcast (Idx 4) idx);
    let (m0, val) = %mem.load (m0, val_arr);
    let m0 = %mem.free (m0, arr);

    return (m0, m1, val);
