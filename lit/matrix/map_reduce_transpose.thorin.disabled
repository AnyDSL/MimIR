// RUN: rm -f %t.ll
// RUN: %thorin -o - %s | FileCheck %s

.plugin core;
.plugin matrix;

// .let MT = (2, (2,4), %core.I32);

.lam .extern identity [a:%core.I32] -> %core.I32 = {
    a
};

.lam .extern addition [a:%core.I32, b:%core.I32] -> %core.I32 = {
    %core.wrap.add %core.i32 0 (a,b)
};

.lam .extern fun [mem:%mem.M, acc:%core.I32, [a:%core.I32]] -> %core.I32 = {
    %core.wrap.add %core.i32 0 (acc,a)
};

.con .extern f [mem : %mem.M, 
    kl: «2: .Nat; .Nat»,
    M:%matrix.Mat (2,kl,%core.I32),
    return: .Cn[%mem.M, %matrix.Mat (2,(kl#(1:(.Idx 2)),kl#(0:(.Idx 2))),%core.I32)]] = {
    // .let v2 = %core.wrap.add (0, %core.i32) (v, v);
    .let (k,l) = kl;
    // .let add = %core.wrap.add (0, %core.i32);


    .let MT = M;
    .let (mem2,MT2) = %matrix.map_reduce
        (
            2, (l,k), %core.I32,
            1,
            2,
            (%core.I32),
            ((k,l))
        )
        (
            mem,
            0:%core.I32,
            fun,
            (
                ((1,0),M)
            )
        )
        ;
        // (
        //     0:%core.I32,
        //     addition,
        //     identity,
        //     (((1,0),M))
        // );


    return (mem, MT)
};

// .lam .extern cont: .Cn [mem : %mem.M, m : (%matrix.Mat MT), return : .Cn [%mem.M, %core.I32]] = {
//     .ff,
//     .let m2 = %matrix.map (2,(2,4),%core.I32,%core.I32) (m,f);
//     .let idx = (1:(.Idx 2),3:(.Idx 4));
//     .let d = %matrix.read MT (m2, idx);
//     return (mem, d)
// };

