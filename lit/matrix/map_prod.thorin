.import core;
.import mem;
.import matrix;

.let _32 = 4294967296;
.let I32 = .Idx _32;
.let u8 = .Idx 256;
.let String = %mem.Ptr («⊤:.Nat; .Idx 256», 0);

.con atoi [%mem.M, String, .Cn [%mem.M, I32]];
.con print_int_matrix [%mem.M, 
    k:.Nat, l:.Nat, 
    %matrix.Mat (2,(k,l),I32),
    .Cn [%mem.M]];

.con .extern f [mem : %mem.M, 
    [k:.Nat, l:.Nat],
    return: .Cn[%mem.M]] = {

    .let (mem2, M) = %matrix.constMat (2,(k,l),I32) (mem, 3:I32);
    // .let (mem2, N) = %matrix.constMat (2,(k,l),I32) (mem, 5:I32);

    print_int_matrix (mem2, k, l, M, return)
    // return mem2
};

.con .extern main [mem1 : %mem.M, 
        argc : I32, 
        argv : %mem.Ptr («⊤:.Nat; String», 0:.Nat), // const char *argv[]
        return : .Cn [%mem.M, I32]
    ] = {

    .con return_cont [mem: %mem.M] = {
        return (mem, 0:I32)
    };

    .let arg1_ptr = %mem.lea (⊤:.Nat, ‹⊤:.Nat; String›, 0) (argv, 1:I32); // argv+1 : const char**
    .let (mem2,arg1) = %mem.load (String, 0) (mem1, arg1_ptr); // argv[1] : const char*

    .let arg2_ptr = %mem.lea (⊤:.Nat, ‹⊤:.Nat; String›, 0) (argv, 2:I32); // argv+2
    .let (mem3,arg2) = %mem.load (String, 0) (mem2, arg2_ptr); // argv[2]

    .con atoi_cont_1 [mem : %mem.M, a : I32] = {
        .con atoi_cont_2 [mem : %mem.M, b : I32] = {
            // return (mem, 42:I32)
            .let a_nat = %core.bitcast (.Nat, I32) a;
            .let b_nat = %core.bitcast (.Nat, I32) b;
            f (mem, (a_nat,b_nat), return_cont)
        };
        atoi (mem, arg2, atoi_cont_2)
    };

    // .let (mem2,m) = %matrix.constMat MT (mem,c);
    // cont (mem2, m, return)
    // return (mem3, 0:I32)
    atoi (mem3, arg1, atoi_cont_1)
};
