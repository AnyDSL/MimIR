// RUN: rm -f %t.ll ; \
// RUN: %thorin -d matrix -d affine -d direct -d clos -d math -o - --output-ll %t.ll %s 
// RUN: clang %S/lib.c %t.ll -o %t -Wno-override-module
// RUN: %t 2 3 | FileCheck %s

.import core;
.import mem;
.import matrix;

.let _32 = 4294967296;
.let I32 = .Idx _32;
.let _f64_p = 52;
.let _f64_e = 11;
.let _f64 = (_f64_p, _f64_e);
.let F64 = %math.F _f64;
.let MT1 = (2, (2,4), F64);
// .let MT2 = (2, (4,3), F64);

.con print_int_matrix    [mem: %mem.M, k: .Nat, l: .Nat, m: %matrix.Mat (2, (⊤:.Nat,⊤:.Nat), I32), return : .Cn [%mem.M]];
.con print_double_matrix [mem: %mem.M, k: .Nat, l: .Nat, m: %matrix.Mat (2, (⊤:.Nat,⊤:.Nat), F64), return : .Cn [%mem.M]];

.con print_int_matrix_wrap [mem: %mem.M, k: .Nat, l: .Nat, m: %matrix.Mat (2, (k,l), I32), return : .Cn [%mem.M]] = {
    .let m2 = %core.bitcast  (%matrix.Mat (2,(⊤:.Nat,⊤:.Nat),I32),%matrix.Mat (2,(k,l),I32)) m;
    print_int_matrix(mem, k, l, m2, return)
};

.con print_double_matrix_wrap [mem: %mem.M, k: .Nat, l: .Nat, m: %matrix.Mat (2, (k,l), F64), return : .Cn [%mem.M]] = {
    .let m2 = %core.bitcast  (%matrix.Mat (2,(⊤:.Nat,⊤:.Nat),F64),%matrix.Mat (2,(k,l),F64)) m;
    print_double_matrix(mem, k, l, m2, return)
};


.lam .extern internal_mapRed_matrix_const
    ![m: .Nat, l: .Nat, [p: .Nat, e:.Nat]] ->
    (.Cn[
        [mem:%mem.M],
        .Cn[%mem.M,%matrix.Mat (2,(m, l),%math.F (p,e))]
    ]) 
    = {
    .let R = %math.F (p,e);

    .con const_comb [[mem:%mem.M, acc:R, []], ret:.Cn[%mem.M,R]] = {
        // .let v = %math.arith.mul (p,e) 0 (a,b);

        // reduce op = addition
        // .let new_acc = %math.arith.add (p,e) 0 (acc,v);
        .let new_acc = acc;
        ret (mem, new_acc)
    };
    .con inner_matrix_const
        ![
            [
                mem:%mem.M,
            ],
            ret: .Cn[%mem.M,%matrix.Mat (2,(m, l),R)]
        ]
    = {
        .let zero_64 = 0.0:(%math.F (52,11));
        .let zero_real = %math.conv.f2f (52,11) (p,e) zero_64;
        ret (
            %matrix.mapReduce
                (2, (m, l), R, 
                    0,
                    (),
                    (),
                    ()
                )
                (
                    mem,
                    zero_real,
                    const_comb,
                    ()
                )
        )
    };
    inner_matrix_const
};


.con .extern main [mem : %mem.M, argc : I32, argv : %mem.Ptr (%mem.Ptr (.Idx 256, 0:.Nat), 0:.Nat), return : .Cn [%mem.M, I32]] = {
    .con return_cont [mem:%mem.M] = return (mem, 0:I32);

    .let c = 42.0:F64;
    .let (mem2,m1) = %matrix.constMat MT1 (mem,c);
    // .let (mem3,m2) = %matrix.constMat MT2 (mem2,d);

    // .let (mem4, mP) = %matrix.prod (2,4,3, _f64) (mem3, m1, m2);
    print_double_matrix_wrap (mem2, 2, 4, m1, return_cont)
    // print_double_matrix_wrap (mem4, 2, 3, mP, return_cont)
};

// CHECK: 3, 3, 3, 3,
// CHECK: 3, 3, 3, 3,
