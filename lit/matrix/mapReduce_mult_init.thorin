// RUN: rm -f %t.ll ; \
// RUN: %thorin -d matrix -e thorin %s -e ll -o %t | FileCheck %s
// RUN: clang %t.ll -o %t -Wno-override-module
// RUN: %t ; test $? -eq 5
// RUN: %t 1 2 3 ; test $? -eq 5
// RUN: %t a b c d e f ; test $? -eq 5

// ./build/bin/thorin -d matrix ./lit/matrix/mapReduce.thorin --output-thorin -

.import core;
.import mem;
.import matrix;

.let _32 = 4294967296;
.let I32 = .Idx _32;
// .let MT = (2, (2,4), I32);

.cn .extern fun [[mem:%mem.M, acc:I32, [a:I32, b:I32]], ret:.Cn[%mem.M,I32]] = {
    .let v = %core.wrap.mul (0, _32) (a,b);

    // reduce op = addition
    .let new_acc = %core.wrap.add (0:.Nat, _32) (acc,v);

    ret (mem, new_acc)
};

.cn .extern f [mem : %mem.M, 
    [k:.Nat, l:.Nat, m:.Nat],
    // M:%matrix.Mat (2,(k,m),I32),
    // N:%matrix.Mat (2,(m,l),I32),
    // return: .Cn[%mem.M, %matrix.Mat (2,(k,l),I32)]] = {
    return: .Cn[%mem.M]] = {

    .let (mem2, M) = %matrix.constMat (2,(k,m),I32) (mem, 42:I32);
    .let (mem3, N) = %matrix.constMat (2,(m,l),I32) (mem2, 44:I32);

    // .let mem4 = mem3;
    .let (mem4,MN) = %matrix.mapReduce
        (
            2, (k,l), I32,
            2,
            (2,2),
            (I32,I32),
            ((k,m),(m,l))
        )
        (
            mem3,
            0:I32,
            fun,
            (
                ((0,2),M),
                ((2,1),N)
            )
        )
        ;


    return (mem4)
};

// .lam .extern cont: .Cn [mem : %mem.M, m : (%matrix.Mat MT), return : .Cn [%mem.M, I32]] = {
//     .ff,
//     .let m2 = %matrix.map (2,(2,4),I32,I32) (m,f);
//     .let idx = (1:(.Idx 2),3:(.Idx 4));
//     .let d = %matrix.read MT (m2, idx);
//     return (mem, d)
// };

