/// # The fun Plugin {#fun}
///
/// @see thorin::fun
///
/// [TOC]
///
/// This plugin provides several abstractions from functional programming.
///
/// ## Operations
///
/// ### %fun.br
///
/// Wrapper for a conditional branch.
/// @warning type inference not working
///
.lam %fun.br!.(T: *, U: *)(cond: .Bool, t: T -> U, f: T -> U, arg: T): U = (f, t)#cond arg;
///
/// ### %fun.zip
///
/// [Zips](https://en.wikipedia.org/wiki/Zipping_(computer_science)) several tensors.
///
/// **Warning**: For now, not a better place for this and will be moved elsewhere.
/// What is more, the signature will likely change in the future:
/// * `r`: rank of the tensors to zip
/// * `s`: shape of the tensors to zip
/// * `ni`: number if inputs
/// * `no`: number if outputs
/// * `Is`: tuple with `ni` many elements that describe the element types of the inputs
/// * `Os`: tuple with `no` many elements that describe the element types of the outputs
/// * `f`: zipping function that expects an `ni`-tuple whose elements correspond to `Is` and yields an `no`-tuple whose element types correspond to `Os`
/// * `is`: the actual input tensors
///
.ax %fun.zip: Π [r: .Nat, s: «r; .Nat», ni: .Nat, Is: «ni; *», no: .Nat, Os: «no; *»]
                [f: «i: ni; Is#i» -> «o: no; Os#o»]
                [is: «i: ni; «s; Is#i»»] -> «o: no; «s; Os#o»», normalize_zip;
///
/// ### %fun.map
///
/// [Zips](https://en.wikipedia.org/wiki/Zipping_(computer_science)) several tensors.
///
/// **Warning**: For now, not a better place for this and will be moved elsewhere.
/// What is more, the signature will likely change in the future:
/// * `r`: rank of the tensors to zip
/// * `s`: shape of the tensors to zip
/// * `ni`: number if inputs
/// * `no`: number if outputs
/// * `Is`: tuple with `ni` many elements that describe the element types of the inputs
/// * `Os`: tuple with `no` many elements that describe the element types of the outputs
/// * `f`: zipping function that expects an `ni`-tuple whose elements correspond to `Is` and yields an `no`-tuple whose element types correspond to `Os`
/// * `is`: the actual input tensors
///
//.ax %fun.zip: Π [r: .Nat, s: «r; .Nat», ni: .Nat, Is: «ni; *», no: .Nat, Os: «no; *»]
                //[f: «i: ni; Is#i» -> «o: no; Os#o», is: «i: ni; «s; Is#i»»] -> «o: no; «s; Os#o»», normalize_zip;
