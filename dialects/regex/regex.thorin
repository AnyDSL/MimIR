/// # The regex Plugin {#regex}
///
/// @see thorin::regex
///
/// [TOC]
///
/// A normalizing regex plugin
///
/// ## Dependencies
///
.import core;
.import mem;
.import compile;
.plugin direct;
///
/// ## Types
///
/// ### RE
///
/// A regular expression matcher.
.let RE = Π[n: .Nat][%mem.M, %mem.Ptr0 «n; %core.I8», .Idx n] -> [%mem.M, .Bool, .Idx n];

/// ## Meta
///
/// ### %regex.conj
/// 
/// A sequence of RE's, e.g. `\d\d\d` matching 3 digits:
/// `%regex.conj (%regex.cls.d, %regex.cls.d, %regex.cls.d)
///
.ax %regex.conj: Π[n: .Nat][<<n; RE>>] -> RE, normalize_conj, 2;

///
/// ### %regex.disj
///
/// Match any of the sub expressions: `[0123456789]`
///
.ax %regex.disj: Π[n: .Nat][<<n; RE>>] -> RE, normalize_disj, 2;

///
/// ### %regex.group
///
/// A capture group
///
.ax %regex.group: Π[n: .Nat][<<n; RE>>] -> RE, normalize_group, 2;

///
/// ## Values
///
/// ### %regex.lit
///
/// Wraps a literal.
///
.ax %regex.lit: Π val:%core.I8 -> RE, normalize_lit, 1;

///
/// ### %regex.cls.*
/// 
/// | Subtag | Matches |
/// | ------ | ------- |
/// | `d`    | digits `[0-9]`|
/// | `D`    | No digits |
/// | `w`    | word characters `[a-zA-Z_0-9]` |
/// | `W`    | No word characters |
/// | `s`    | whitespace `[ \t\r\n]` |
/// | `S`    | No whitespace |
/// | `any`  | Any character |
.ax %regex.cls(d,D,w,W,s,S,any): RE, normalize_cls, 0;

/// ## Quantifiers
///
/// ### %regex.quant.*
///
.ax %regex.quant(zeroOrOne,zeroOrMore,oneOrMore): Π RE -> RE, normalize_quant, 1;

///
/// ## Implementation
///
.lam CPS_RE![n: .Nat] = .Cn [[%mem.M, %mem.Ptr0 «n; %core.I8», .Idx n], .Cn[%mem.M, .Bool, .Idx n]];

.con %regex.match_d!(n: .Nat)!((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .let ptr = %mem.lea (n, ‹n; %core.I8›, 0) (string, pos);
    .let (`mem, char) = %mem.load (mem, ptr);
    .let is_digit = %core.bit2.and_ 0 (%core.icmp.uge (char, '0'),  %core.icmp.ule (char, '9'));
    
    .let new_pos = (pos, %core.conv.u n (%core.wrap.add 0 (%core.conv.u %core.i32 pos, 1:%core.I32)))#is_digit;
    cont (mem, is_digit, new_pos)
};
.con %regex.match_D!(n: .Nat)!((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .con ret_inverted!(mem: %mem.M, is_digit: .Bool, new_pos: .Idx n) = {
        cont (mem, %core.bit1.neg 0 is_digit, new_pos)
    };
    %regex.match_d n ((mem, string, pos), ret_inverted)
};
.con %regex.match_w!(n: .Nat)!((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .let ptr = %mem.lea (n, ‹n; %core.I8›, 0) (string, pos);
    .let (`mem, char) = %mem.load (mem, ptr);
    .let is_upper_lit = %core.bit2.and_ 0 (%core.icmp.uge (char, 'A'),  %core.icmp.ule (char, 'Z'));
    .let is_lower_lit = %core.bit2.and_ 0 (%core.icmp.uge (char, 'a'),  %core.icmp.ule (char, 'z'));
    .let is_underscore = %core.icmp.e (char, '_');
    .let is_digit = %core.bit2.and_ 0 (%core.icmp.uge (char, '0'),  %core.icmp.ule (char, '9'));
    .let is_w = %core.bit2.or_ 0 (%core.bit2.or_ 0 (is_upper_lit, is_lower_lit), %core.bit2.or_ 0 (is_underscore, is_digit));
    
    .let new_pos = (pos, %core.conv.u n (%core.wrap.add 0 (%core.conv.u %core.i32 pos, 1:%core.I32)))#is_w;
    cont (mem, is_w, new_pos)
};
.con %regex.match_W!(n: .Nat)!((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .con ret_inverted!(mem: %mem.M, is_w: .Bool, new_pos: .Idx n) = {
        cont (mem, %core.bit1.neg 0 is_w, new_pos)
    };
    %regex.match_w n ((mem, string, pos), ret_inverted)
};
.con %regex.match_s!(n: .Nat)!((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .let ptr = %mem.lea (n, ‹n; %core.I8›, 0) (string, pos);
    .let (`mem, char) = %mem.load (mem, ptr);
    .let is_space = %core.icmp.e (char, ' ');
    .let is_tab = %core.icmp.e (char, '\t');
    .let is_nf = %core.icmp.e (char, '\n');
    .let is_cr = %core.icmp.e (char, '\r');
    .let is_s = %core.bit2.or_ 0 (%core.bit2.or_ 0 (is_space, is_tab), %core.bit2.or_ 0 (is_nf, is_cr));
    
    .let new_pos = (pos, %core.conv.u n (%core.wrap.add 0 (%core.conv.u %core.i32 pos, 1:%core.I32)))#is_s;
    cont (mem, is_s, new_pos)
};
.con %regex.match_S!(n: .Nat)!((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .con ret_inverted!(mem: %mem.M, is_s: .Bool, new_pos: .Idx n) = {
        cont (mem, %core.bit1.neg 0 is_s, new_pos)
    };
    %regex.match_s n ((mem, string, pos), ret_inverted)
};
.con %regex.match_any!(n: .Nat)!((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .let ptr = %mem.lea (n, ‹n; %core.I8›, 0) (string, pos);
    .let (`mem, char) = %mem.load (mem, ptr);
    .let isnt_0 = %core.icmp.ne (char, '\0');

    .let new_pos = (pos, %core.conv.u n (%core.wrap.add 0 (%core.conv.u %core.i32 pos, 1:%core.I32)))#isnt_0;
    cont (mem, isnt_0, new_pos)
};
.con %regex.match_lit!(lit:%core.I8)!(n: .Nat)!((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .let ptr = %mem.lea (n, ‹n; %core.I8›, 0) (string, pos);
    .let (`mem, char) = %mem.load (mem, ptr);
    .let is_lit = %core.icmp.e (char, lit);

    .let new_pos = (pos, %core.conv.u n (%core.wrap.add 0 (%core.conv.u %core.i32 pos, 1:%core.I32)))#is_lit;
    cont (mem, is_lit, new_pos)
};
.con %regex.match_conj!(n: .Nat)!(A: (CPS_RE n), B: (CPS_RE n))((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .con exit_true!((mem: %mem.M, new_pos: .Idx n)) = {
        cont (mem, 1:.Bool, new_pos)
    };

    .con exit_false!((mem: %mem.M, new_pos: .Idx n)) = {
        cont (mem, 0:.Bool, pos)
    };

    .con B_ret!(mem:%mem.M, matched:.Bool, new_pos:.Idx n) = {
        (exit_false, exit_true)#matched (mem, new_pos)
    };
    .con A_ret!(mem:%mem.M, matched:.Bool, new_pos:.Idx n) = {
        .con call_B!(mem:%mem.M, new_pos:.Idx n) = {
            B ((mem, string, new_pos), B_ret)
        };
        (exit_false, call_B)#matched (mem, new_pos)
    };

    A ((mem, string, pos), A_ret)
};
.con %regex.match_disj!(n: .Nat)!(A: (CPS_RE n), B: (CPS_RE n))((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .con exit_true!((mem: %mem.M, new_pos: .Idx n)) = {
        cont (mem, 1:.Bool, new_pos)
    };

    .con exit_false!((mem: %mem.M, new_pos: .Idx n)) = {
        cont (mem, 0:.Bool, pos)
    };

    .con B_ret!(mem:%mem.M, matched:.Bool, new_pos:.Idx n) = {
        (exit_false, exit_true)#matched (mem, new_pos)
    };
    .con A_ret!(mem:%mem.M, matched:.Bool, new_pos:.Idx n) = {
        .con call_B!(mem:%mem.M, new_pos:.Idx n) = {
            B ((mem, string, new_pos), B_ret)
        };
        (call_B, exit_true)#matched (mem, new_pos)
    };

    A ((mem, string, pos), A_ret)
};
.con %regex.match_zeroOrOne!(n: .Nat)!(sub: (CPS_RE n))((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .con exit_true!((mem: %mem.M, new_pos: .Idx n)) = {
        cont (mem, 1:.Bool, new_pos)
    };

    .con exit_false!((mem: %mem.M, new_pos: .Idx n)) = {
        cont (mem, 1:.Bool, pos)
    };
    .con ret!(mem:%mem.M, matched:.Bool, new_pos:.Idx n) = {
        (exit_false, exit_true)#matched (mem, new_pos)
    };

    sub ((mem, string, pos), ret)
};
.con %regex.match_zeroOrMore!(n: .Nat)!(sub: (CPS_RE n))((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .con exit_false((mem: %mem.M, new_pos: .Idx n)) = {
        cont (mem, 1:.Bool, new_pos)
    };
    .con ret(mem:%mem.M, matched:.Bool, new_pos:.Idx n) = {
        .con exit_true((mem: %mem.M, new_pos: .Idx n)) = {
            sub ((mem, string, new_pos), ret)
        };
        (exit_false, exit_true)#matched (mem, new_pos)
    };

    sub ((mem, string, pos), ret)
};
.con %regex.match_oneOrMore!(n: .Nat)!(sub: (CPS_RE n))((mem: %mem.M, string: %mem.Ptr0 «n; %core.I8», pos: .Idx n), cont: .Cn[%mem.M, .Bool, .Idx n]) = {
    .con ret(mem:%mem.M, matched:.Bool, new_pos:.Idx n) = {
        .con iter!((mem: %mem.M, new_pos: .Idx n)) = {
            sub ((mem, string, new_pos), ret)
        };
        .con exit_true((mem: %mem.M, new_pos: .Idx n)) = {
            cont (mem, 1:.Bool, new_pos)
        };
        (exit_true, iter)#matched (mem, new_pos)
    };

    .con ret1!(mem:%mem.M, matched:.Bool, new_pos:.Idx n) = {
        .con continue!((mem: %mem.M, new_pos: .Idx n)) = {
            sub ((mem, string, new_pos), ret)
        };
        .con exit_false!((mem: %mem.M, new_pos: .Idx n)) = {
            cont (mem, 0:.Bool, new_pos)
        };
        (exit_false, continue)#matched (mem, new_pos)
    };

    sub ((mem, string, pos), ret1)
};

/// ## Passes and Phases
/// 
/// ### Passes
/// 
.ax %regex.lower_regex: %compile.Pass;

