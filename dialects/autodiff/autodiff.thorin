/// # The automatic differentiation dialect {#autodiff}
///
/// [TOC]
///
/// <TODO:>
///
/// ## Dependencies
///
.import direct;
.import mem;
///
/// ## Types
///
.ax %autodiff.tangent_type: * -> *, normalize_tangent_type;
///
/// ## Operations
///
/// ### %autodiff.autodiff
/// 
/// operates on functions and types
///
.ax %autodiff.autodiff: Π [T: *] -> T -> 
    %autodiff.autodiff T, 
    normalize_autodiff;
///
/// ### %autodiff.zero
/// 
/// a universal zero such that (zero T) +_T t = t
///
.ax %autodiff.zero: Π [T:*] -> T, normalize_zero;
///
///
/// ## Substitution Rules
/// 
/// ### Types
/// 
/// #### Auxiliary Definitions
/// 
/// some definitions used in the substitution rules below
/// 
.let I32 = %Int 4294967296;
.let R32 = %Real 4294967296;
/// 
/// 
/// #### AutoDiff type
/// 
/// TODO: text
/// 
/// `(T -> U)ᴬ` ↦ `Tᴬ -> Uᴬ × (Uᵀ -> Tᵀ)` 
/// TODO: check memory (in T, U)
.rule (T:*) (U:*) :
    (%autodiff.autodiff (.Cn [T, .Cn U])) ->
    .Cn [(%autodiff.autodiff T),
         (.Cn [(%autodiff.autodiff U),
             (.Cn [(%autodiff.tangent_type U),
                 (%autodiff.tangent_type T)
             ])
         ])
    ];
/// `r: R` ↦ `r`
.rule (n:.Nat):
    (%autodiff.autodiff (.Real n)) ->
    (.Real n);
/// `+` ↦ 
/// ```
/// λ (a,b). (
///   + (a,b),
///   λ s. (s*b, s*a)
/// )
/// ``` 
/// TODO: %core.wrap.add vs %Wrap_add
/// TODO: direct function vs ds2cps
/// cascading function = direct call that returns a cps function
/// (should be handled automatically by the direct dialect)
.cn add_deriv [m:.Nat, n:.Nat]
    [[a:(.Real n), b:(.Real n)], ret:(.Cn (.Real n))] = {
    .let result = %ROp_add (m,n) (a,b);
    .cn add_pb [s:(.Real n), pb_ret:(.Cn [.Real n, .Real n])] = {
        .let lhs = %ROp_add (m,n) (s,b);
        .let rhs = %ROp_add (m,n) (s,a);
        pb_ret (lhs, rhs)
    };
    ret (result,add_pb)
};
.rule (m:.Nat) (n:.Nat):
    (%ROp_add (m,n)) ->
    %direct.cps2ds (add_deriv (m,n));
///
/// 
/// #### Tangent type
/// 
/// the tangent is the argument and result of the pullbacks
/// they hold the gradients
/// 
/// the tangent of a function is undefined
/// TODO: mem tangent
.rule (T:*) :
    (%autodiff.tangent_type .Cn T) ->
    R32;
/// `r: R` ↦ `r`
.rule (n:.Nat):
    (%autodiff.tangent_type (.Real n)) ->
    (.Real n);
/// 
/// 
/// #### AutoDiff expressions







// notes:

// rule syntax
// .rule args :
//     lhs -> rhs

// function convention
// .Cn [[mem, [args]], .Cn [mem, [outs]]]
// .Cn [[mem, [A, B, C]], .Cn [mem, [X, Y]]]