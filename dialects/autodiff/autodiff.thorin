/// # The automatic differentiation dialect {#autodiff}
///
/// [TOC]
///
/// <TODO:>
/// 
/// Transformations:
/// - autodiff
///   - on types
///     computed the augmented derivation type of a function type
///     `autodiff (T -> U) = (T -> U × (U -> T))`
///   - on closed terms (functions, operators, higher-order argument, registered instance, ... (if I forgot something))
///     replaces the term with the augmented term that computes and simultaneously returns the modular full pullback
///     `autodiff f = f' = λ args. (f args, f*)` 
/// - tangent type
///   remaining type transformation
///   zero for non-differentiable types
///   structure preserving functor for non-exponential containers
/// - partial pullback
///   pullback computation for non-closed terms
///   always acts with in a function environment
///   C++ function (in meta space)
///   importantly acts on tuples and
///     (function) applications (uses autodiff here)
///
/// ## Dependencies
///
.import mem;
/// for derivatives
.import core;
.import direct;
///
///
/// ## Types
///
.ax %autodiff.tangent_type: * -> *, normalize_tangent_type;
///
/// ## Operations
///
/// ### %autodiff.autodiff
/// 
/// operates on functions and types
///
.ax %autodiff.autodiff_type: * -> *, 
    normalize_autodiff_type;
.ax %autodiff.autodiff: Π [T: *] -> T -> 
    %autodiff.autodiff_type T, 
    normalize_autodiff;
///
/// ### %autodiff.zero
/// 
/// a universal zero such that (zero T) +_T t = t
///
.ax %autodiff.zero: Π [T:*] -> T, normalize_zero;
///
/// ### %autodiff.add
/// 
/// a universal add
///
/// TODO: how do we handle summations that need memory? (grab current memory?)
.ax %autodiff.add: Π [T:*] -> [T,T] -> T, normalize_add;
.ax %autodiff.sum: Π [n:.Nat,T:*] -> «n; T» -> T, normalize_sum;
///
///

// .cn add_deriv [m:.Nat, n:.Nat]
//     [[a:(.Real n), b:(.Real n)], ret:(.Cn (.Real n))] = {
//     .let result = %ROp_add (m,n) (a,b);
//     .cn add_pb [s:(.Real n), pb_ret:(.Cn [.Real n, .Real n])] = {
//         .let lhs = %ROp_add (m,n) (s,b);
//         .let rhs = %ROp_add (m,n) (s,a);
//         pb_ret (lhs, rhs)
//     };
//     ret (result,add_pb)
// };


/// mul' => args -> result*pullback
/// call: r    = mul  (m,w) (a,b) 
/// res : r,r* = mul' (m,w) (a,b)
/// we shorten (Int w) to Int
/// mul : Π [m:.Nat,w:.Nat] -> [a:Int,b:Int] -> Int
/// r   : Int
/// r*  : cn[Int,cn[Int,Int]]
/// the pullback has to be in cps for compliance
/// mul* := λ s. (s*b,s*a)
/// 
/// version 1: mul' as direct style function
/// mul'_ds : Π [m:.Nat,w:.Nat] -> [a:Int,b:Int] -> [Int,cn[Int,cn[Int,Int]]]
/// r,r* = mul'_ds (m,w) (a,b)
/// 
/// version 2: mul' as cps style function
/// mul'_cps : Π [m:.Nat,w:.Nat] -> cn[[Int,Int],cn[Int,   cn[Int,cn[Int,Int]]]]
/// r,r* = (cps2ds (mul'_cps (m,w))) (a,b)
/// 
/// both are normalizing by one inlining step
/// the ds version is more direct
/// but needs a ds handling of inlining

.lam .extern mul_deriv_ds 
    [m:.Nat, w:.Nat] -> 
    ([%Int w, %Int w] -> [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]])
    = {
    .lam inner_mul_deriv_ds 
        [a:(%Int w), b:(%Int w)] ->
        [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]
        = {
        .let result = %core.wrap.mul (m,w) (a,b);
        .cn mul_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
            .let lhs = %core.wrap.mul (m,w) (s,b);
            .let rhs = %core.wrap.mul (m,w) (s,a);
            pb_ret (lhs, rhs)
        };
        (result,mul_pb)
    };
    inner_mul_deriv_ds
};


.lam .extern mul_deriv_cps
    [m:.Nat, w:.Nat] -> 
    (.Cn[[%Int w, %Int w], .Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]])
    = {
    .cn inner_mul_deriv_cps
        [[a:%Int w, b:%Int w], ret:.Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]]
        = {
        .let result = %core.wrap.mul (m,w) (a,b);
        .cn mul_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
            .let lhs = %core.wrap.mul (m,w) (s,b);
            .let rhs = %core.wrap.mul (m,w) (s,a);
            pb_ret (lhs, rhs)
        };
        ret (result,mul_pb)
    };
    inner_mul_deriv_cps
};

/// TODO:
///   best of both worlds?
///   or just use the ds version?
.lam .extern mul_deriv_ds_by_cps
    [m:.Nat, w:.Nat] -> 
    ([%Int w, %Int w] -> [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]])
    = {
    .cn inner_mul_deriv_cps
        [[a:%Int w, b:%Int w], ret:.Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]]
        = {
        .let result = %core.wrap.mul (m,w) (a,b);
        .cn mul_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
            .let lhs = %core.wrap.mul (m,w) (s,b);
            .let rhs = %core.wrap.mul (m,w) (s,a);
            pb_ret (lhs, rhs)
        };
        ret (result,mul_pb)
    };
    %direct.cps2ds (
        [%Int w, %Int w],
        [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]
    )
    inner_mul_deriv_cps
};


// /// ## Substitution Rules
// /// 
// /// ### Types
// /// 
// /// #### Auxiliary Definitions
// /// 
// /// some definitions used in the substitution rules below
// /// 
// .let I32 = %Int 4294967296;
// .let R32 = %Real 4294967296;
// /// 
// /// 
// /// #### AutoDiff 
// /// 
// /// TODO: text
// /// 
// /// `(T -> U)ᴬ` ↦ `Tᴬ -> Uᴬ × (Uᵀ -> Tᵀ)` 
// /// TODO: check memory (in T, U)
// .rule (T:*) (U:*) :
//     (%autodiff.autodiff (.Cn [T, .Cn U])) ->
//     .Cn [(%autodiff.autodiff T),
//          (.Cn [(%autodiff.autodiff U),
//              (.Cn [(%autodiff.tangent_type U),
//                  (%autodiff.tangent_type T)
//              ])
//          ])
//     ];
// /// `r: R` ↦ `r`
// .rule (n:.Nat):
//     (%autodiff.autodiff (.Real n)) ->
//     (.Real n);
// /// `+` ↦ 
// /// ```
// /// λ (a,b). (
// ///   + (a,b),
// ///   λ s. (s*b, s*a)
// /// )
// /// ``` 
// /// TODO: %core.wrap.add vs %Wrap_add
// /// TODO: direct function vs ds2cps
// /// cascading function = direct call that returns a cps function
// /// (should be handled automatically by the direct dialect)
// .cn add_deriv [m:.Nat, n:.Nat]
//     [[a:(.Real n), b:(.Real n)], ret:(.Cn (.Real n))] = {
//     .let result = %ROp_add (m,n) (a,b);
//     .cn add_pb [s:(.Real n), pb_ret:(.Cn [.Real n, .Real n])] = {
//         .let lhs = %ROp_add (m,n) (s,b);
//         .let rhs = %ROp_add (m,n) (s,a);
//         pb_ret (lhs, rhs)
//     };
//     ret (result,add_pb)
// };
// .rule (m:.Nat) (n:.Nat):
//     (%ROp_add (m,n)) ->
//     %direct.cps2ds (add_deriv (m,n));
// /// `(a,b)ᴬ` ↦ `(a,b)`
// ///
// /// 
// /// #### Tangent type
// /// 
// /// the tangent is the argument and result of the pullbacks
// /// they hold the gradients
// /// 
// /// the tangent of a function is undefined
// /// TODO: mem tangent
// .rule (T:*) :
//     (%autodiff.tangent_type .Cn T) ->
//     R32;
// /// `r: R` ↦ `r`
// .rule (n:.Nat):
//     (%autodiff.tangent_type (.Real n)) ->
//     (.Real n);
// /// `(«i: n; T#i»)ᴬ` ↦ `«i: n; (T#i)ᴬ»`
// /// TODO: is this (a/the) normal form of tuples/sigmas
// ///     but then T is a tuple?
// ///     are there two kinds of tuples? (Meta and Thorin)
// .rule (n:.Nat) (T:«n; *»):
//     (%autodiff.tangent_type («i: n; T#i»)) ->
//     («i: n; %autodiff.tangent_type (T#i)»);
// /// 
// /// #### expressions
// /// 
// /// 
// .rule (T:*) (a:T):
//     (%autodiff.add T (a,%autodiff.zero T)) ->
//     a;
// .rule (T:*) (a:T):
//     (%autodiff.add T (%autodiff.zero T,a)) ->
//     a;
// /// 
// .rule (n:.Nat):
//     (%autodiff.add (.Real n)) ->
//     (%ROp_add (0,n));


/// autodiff only applies to closed terms
/// for instance, functions or operators
/// for a thorin function f:
/// autodiff f = λ args. (f args, ppb_f body)

/// partial pullback (ppb) => C++ function that returns the partially applied pullback
/// ppb applies to open expressions in a function
/// `ppb (a,b) = ppb a + ppb b` (+ is liftet over arbitrary structure)
/// ```
/// ppb (f args) = 
/// let (res, f*) = autodiff f args in
///     ppb args . f*
/// ```
/// ppb only returns the partially applied pullback, the body remains the same (up to renaming)



/// TODO: meta
/// - sigma
/// - tuple elementwise + sum
/// - pointer
/// - function args
/// - registering




// notes:

// rule syntax
// .rule args :
//     lhs -> rhs

// function convention
// .Cn [[mem, [args]], .Cn [mem, [outs]]]
// .Cn [[mem, [A, B, C]], .Cn [mem, [X, Y]]]