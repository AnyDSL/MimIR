/// # The automatic differentiation dialect {#autodiff}
///
/// [TOC]
///
/// <TODO:>
/// 
/// Transformations:
/// - autodiff
///   - on types
///     computed the augmented derivation type of a function type
///     `autodiff (T -> U) = (T -> U × (U -> T))`
///   - on closed terms (functions, operators, higher-order argument, registered instance, ... (if I forgot something))
///     replaces the term with the augmented term that computes and simultaneously returns the modular full pullback
///     `autodiff f = f' = λ args. (f args, f*)` 
/// - tangent type
///   remaining type transformation
///   zero for non-differentiable types
///   structure preserving functor for non-exponential containers
/// - partial pullback
///   pullback computation for non-closed terms
///   always acts with in a function environment
///   C++ function (in meta space)
///   importantly acts on tuples and
///     (function) applications (uses autodiff here)
///
/// ## Dependencies
///
.import mem;
/// for derivatives
.import core;
.import direct;
///
///
/// ## Types
///
.ax %autodiff.tangent_type: * -> *, normalize_tangent_type;
///
/// ## Operations
///
/// ### %autodiff.autodiff
/// 
/// operates on functions and types
///
.ax %autodiff.autodiff_type: * -> *, 
    normalize_autodiff_type;
.ax %autodiff.autodiff: Π [T: *] -> T -> 
    %autodiff.autodiff_type T, 
    normalize_autodiff;
///
/// ### %autodiff.zero
/// 
/// a universal zero such that (zero T) +_T t = t
///
// TODO: convert to bot:T at codegen
.ax %autodiff.zero: Π [T:*] -> T, normalize_zero;
///
/// ### %autodiff.add
/// 
/// a universal add
///
/// TODO: how do we handle summations that need memory? (grab current memory?)
.ax %autodiff.add: Π [T:*] -> [T,T] -> T, normalize_add;
.ax %autodiff.sum: Π [n:.Nat,T:*] -> «n; T» -> T, normalize_sum;
///
///

// .cn add_deriv [m:.Nat, n:.Nat]
//     [[a:(.Real n), b:(.Real n)], ret:(.Cn (.Real n))] = {
//     .let result = %ROp_add (m,n) (a,b);
//     .cn add_pb [s:(.Real n), pb_ret:(.Cn [.Real n, .Real n])] = {
//         .let lhs = %ROp_add (m,n) (s,b);
//         .let rhs = %ROp_add (m,n) (s,a);
//         pb_ret (lhs, rhs)
//     };
//     ret (result,add_pb)
// };


/// mul' => args -> result*pullback
/// call: r    = mul  (m,w) (a,b) 
/// res : r,r* = mul' (m,w) (a,b)
/// we shorten (Int w) to Int
/// mul : Π [m:.Nat,w:.Nat] -> [a:Int,b:Int] -> Int
/// r   : Int
/// r*  : cn[Int,cn[Int,Int]]
/// the pullback has to be in cps for compliance
/// mul* := λ s. (s*b,s*a)
/// 
/// version 1: mul' as direct style function
/// mul'_ds : Π [m:.Nat,w:.Nat] -> [a:Int,b:Int] -> [Int,cn[Int,cn[Int,Int]]]
/// r,r* = mul'_ds (m,w) (a,b)
/// 
/// version 2: mul' as cps style function
/// mul'_cps : Π [m:.Nat,w:.Nat] -> cn[[Int,Int],cn[Int,   cn[Int,cn[Int,Int]]]]
/// r,r* = (cps2ds (mul'_cps (m,w))) (a,b)
/// 
/// both are normalizing by one inlining step
/// the ds version is more direct
/// but needs a ds handling of inlining

// .lam .extern mul_deriv_ds 
//     [m:.Nat, w:.Nat] -> 
//     ([%Int w, %Int w] -> [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]])
//     = {
//     .lam inner_mul_deriv_ds 
//         [a:(%Int w), b:(%Int w)] ->
//         [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]
//         = {
//         .let result = %core.wrap.mul (m,w) (a,b);
//         .cn mul_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
//             .let lhs = %core.wrap.mul (m,w) (s,b);
//             .let rhs = %core.wrap.mul (m,w) (s,a);
//             pb_ret (lhs, rhs)
//         };
//         (result,mul_pb)
//     };
//     inner_mul_deriv_ds
// };

// folded cascading
// .lam .extern mul_deriv_ds 
//     _::[m:.Nat, w:.Nat] -> 
//     Π [a:%Int w, b:%Int w] -> [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]
//     = {
//         .let result = %core.wrap.mul (m,w) (a,b);
//         .cn mul_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
//             .let lhs = %core.wrap.mul (m,w) (s,b);
//             .let rhs = %core.wrap.mul (m,w) (s,a);
//             pb_ret (lhs, rhs)
//         };
//         (result,mul_pb)
// };


.lam .extern internal_diff_core_wrap_add
    [m:.Nat, w:.Nat] -> 
    (.Cn[[%Int w, %Int w], .Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]])
    = {
    .cn inner_add_deriv_cps
        [[a:%Int w, b:%Int w], ret:.Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]]
        = {
        .let result = %core.wrap.add (m,w) (a,b);
        .cn add_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
            pb_ret (s,s)
        };
        ret (result,add_pb)
    };
    inner_add_deriv_cps
};


.lam .extern internal_diff_core_wrap_mul
    [m:.Nat, w:.Nat] -> 
    (.Cn[[%Int w, %Int w], .Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]])
    = {
    .cn inner_mul_deriv_cps
        [[a:%Int w, b:%Int w], ret:.Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]]
        = {
        .let result = %core.wrap.mul (m,w) (a,b);
        .cn mul_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
            .let lhs = %core.wrap.mul (m,w) (s,b);
            .let rhs = %core.wrap.mul (m,w) (s,a);
            pb_ret (lhs, rhs)
        };
        ret (result,mul_pb)
    };
    inner_mul_deriv_cps
};

/// TODO:
///   best of both worlds?
///   or just use the ds version?
/// 
// .lam .extern mul_deriv_ds_by_cps
//     [m:.Nat, w:.Nat] -> 
//     ([%Int w, %Int w] -> [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]])
//     = {
//     .cn inner_mul_deriv_cps
//         [[a:%Int w, b:%Int w], ret:.Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]]
//         = {
//         .let result = %core.wrap.mul (m,w) (a,b);
//         .cn mul_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
//             .let lhs = %core.wrap.mul (m,w) (s,b);
//             .let rhs = %core.wrap.mul (m,w) (s,a);
//             pb_ret (lhs, rhs)
//         };
//         ret (result,mul_pb)
//     };
//     %direct.cps2ds (
//         [%Int w, %Int w],
//         [%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]
//     )
//     inner_mul_deriv_cps
// };


// the pullback is the derivative with respect to the input (weighted with the out tangent)
// for arithmetic operations, s is simply multiplied to each input tangent
// as formula: the tuple: ∂_i f(x1,...,xn) * s
// you will also come to the conclusion that the applied partial pullback needs to be
// sum x_i*(∂_i f(x1,...,xn) * s)
// = sum x_i*(•) with • as the formula from above
// this is a direct result from the chain composition with the partial pullback of a tuple
// the tuple pullback transports the partial pullbacks of the operands and handles the sums
// by its nature the pullback of a tuple needs to be a sum

// fully cps

// s ↦ (s*b, s*a)
/* 
.cn .extern mul_deriv_cps
[
    [m:.Nat, w:.Nat], 
rcont:.Cn[
    (.Cn[[%Int w, %Int w], .Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]])
]]
    = {
    .cn inner_mul_deriv_cps
        [[a:%Int w, b:%Int w], ret:.Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]]
        = {
        .let result = %core.wrap.mul (m,w) (a,b);
        .cn mul_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
            .let lhs = %core.wrap.mul (m,w) (s,b);
            .let rhs = %core.wrap.mul (m,w) (s,a);
            pb_ret (lhs, rhs)
        };
        ret (result,mul_pb)
    };
    rcont inner_mul_deriv_cps
};

// s ↦ (s, s)
.cn .extern add_deriv_cps
[
    [m:.Nat, w:.Nat], 
rcont:.Cn[
    (.Cn[[%Int w, %Int w], .Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]])
]]
    = {
    .cn inner_add_deriv_cps
        [[a:%Int w, b:%Int w], ret:.Cn[%Int w, .Cn[%Int w, .Cn[%Int w, %Int w]]]]
        = {
        .let result = %core.wrap.add (m,w) (a,b);
        .cn add_pb [s:(%Int w), pb_ret:(.Cn [%Int w, %Int w])] = {
            pb_ret (s,s)
        };
        ret (result,add_pb)
    };
    rcont inner_add_deriv_cps
};

// s ↦ (s, -s)
// sub

// s ↦ (s/b, -s*a/(b*b) = -(a/b)* (s/b))
// div

// compare does not need one


// load : Mem * Ptr(V) -> Mem * V

r = m2,v = load (m,p)
r,r* = (m2,v),r* = load' (m,p)
args = (m,p)

r* : M*V -> M*P(V)
args* : M*P(V) -> A
where args* := λ (sm, sp). m*(sm) + p*(sp)
  m* will most likely be id or zero
  r*,p* can be chosen
r* := λ (sm, sv).
  // or use other memory
  let (sm2, ps) = slot V sm in
  let (sm3) = store (sm2,(ps,sv)) in
  (sm3,sp)
r* is closed => can not argue about partial pullbacks
(but could use load arguments)
v* is necessarily partial

idea: p* := unpack ptr => sv => plug into loaded shadow pb
  question: when to load for correct order
idea: (assume inner pointer for now)
  1. augment arguments; shadow pointer exists
  2. construct load*
    2.1 set p* using current memory (from args) and shadow pointer
  3. compose with args* ∋ p*

Variant 1: Ptr(V)ᵗ = Ptr(Vᵗ)
  load' : Mem * Ptr(V) -> (Mem * V) * (Mem * V -> Mem * Ptr(V))
    // short: M*P(V) -> (M*V) * (M*V -> M*P(V))
  load' := λ m p.
    if shadow p then
        // p_S: Ptr(V -> A)
        // v* : V -> A
        let m2, v* = load m p_S in
        let m3, v = load m2 p;
        // p*: P(V) -> A
        set p* = (wrapped) v* (load ...)
        (
            (m3,v), 
            // r*: 
            // see above
        )
    else


Variant 2: Ptr(V)ᵗ = Vᵗ
  load' : Mem * Ptr(V) -> (Mem * V) * (Mem * V -> Mem * V)
  load' := λ m p.
    if shadow p then
        // p_S: Ptr(V -> A)
        // v* : V -> A
        let m2, v* = load m p_S in
        let m3, v = load m2 p;
        (
            (m3,v), 
            λ s_m s_v.
                v* s_v
        )
    else


*/


// /// ## Substitution Rules
// /// 
// /// ### Types
// /// 
// /// #### Auxiliary Definitions
// /// 
// /// some definitions used in the substitution rules below
// /// 
// .let I32 = %Int 4294967296;
// .let R32 = %Real 4294967296;
// /// 
// /// 
// /// #### AutoDiff 
// /// 
// /// TODO: text
// /// 
// /// `(T -> U)ᴬ` ↦ `Tᴬ -> Uᴬ × (Uᵀ -> Tᵀ)` 
// /// TODO: check memory (in T, U)
// .rule (T:*) (U:*) :
//     (%autodiff.autodiff (.Cn [T, .Cn U])) ->
//     .Cn [(%autodiff.autodiff T),
//          (.Cn [(%autodiff.autodiff U),
//              (.Cn [(%autodiff.tangent_type U),
//                  (%autodiff.tangent_type T)
//              ])
//          ])
//     ];
// /// `r: R` ↦ `r`
// .rule (n:.Nat):
//     (%autodiff.autodiff (.Real n)) ->
//     (.Real n);
// /// `+` ↦ 
// /// ```
// /// λ (a,b). (
// ///   + (a,b),
// ///   λ s. (s*b, s*a)
// /// )
// /// ``` 
// /// TODO: %core.wrap.add vs %Wrap_add
// /// TODO: direct function vs ds2cps
// /// cascading function = direct call that returns a cps function
// /// (should be handled automatically by the direct dialect)
// .cn add_deriv [m:.Nat, n:.Nat]
//     [[a:(.Real n), b:(.Real n)], ret:(.Cn (.Real n))] = {
//     .let result = %ROp_add (m,n) (a,b);
//     .cn add_pb [s:(.Real n), pb_ret:(.Cn [.Real n, .Real n])] = {
//         .let lhs = %ROp_add (m,n) (s,b);
//         .let rhs = %ROp_add (m,n) (s,a);
//         pb_ret (lhs, rhs)
//     };
//     ret (result,add_pb)
// };
// .rule (m:.Nat) (n:.Nat):
//     (%ROp_add (m,n)) ->
//     %direct.cps2ds (add_deriv (m,n));
// /// `(a,b)ᴬ` ↦ `(a,b)`
// ///
// /// 
// /// #### Tangent type
// /// 
// /// the tangent is the argument and result of the pullbacks
// /// they hold the gradients
// /// 
// /// the tangent of a function is undefined
// /// TODO: mem tangent
// .rule (T:*) :
//     (%autodiff.tangent_type .Cn T) ->
//     R32;
// /// `r: R` ↦ `r`
// .rule (n:.Nat):
//     (%autodiff.tangent_type (.Real n)) ->
//     (.Real n);
// /// `(«i: n; T#i»)ᴬ` ↦ `«i: n; (T#i)ᴬ»`
// /// TODO: is this (a/the) normal form of tuples/sigmas
// ///     but then T is a tuple?
// ///     are there two kinds of tuples? (Meta and Thorin)
// .rule (n:.Nat) (T:«n; *»):
//     (%autodiff.tangent_type («i: n; T#i»)) ->
//     («i: n; %autodiff.tangent_type (T#i)»);
// /// 
// /// #### expressions
// /// 
// /// 
// .rule (T:*) (a:T):
//     (%autodiff.add T (a,%autodiff.zero T)) ->
//     a;
// .rule (T:*) (a:T):
//     (%autodiff.add T (%autodiff.zero T,a)) ->
//     a;
// /// 
// .rule (n:.Nat):
//     (%autodiff.add (.Real n)) ->
//     (%ROp_add (0,n));


/// autodiff only applies to closed terms
/// for instance, functions or operators
/// for a thorin function f:
/// autodiff f = λ args. (f args, ppb_f body)

/// partial pullback (ppb) => C++ function that returns the partially applied pullback
/// ppb applies to open expressions in a function
/// `ppb (a,b) = ppb a + ppb b` (+ is liftet over arbitrary structure)
/// ```
/// ppb (f args) = 
/// let (res, f*) = autodiff f args in
///     ppb args . f*
/// ```
/// ppb only returns the partially applied pullback, the body remains the same (up to renaming)



/// TODO: meta
/// - sigma
/// - tuple elementwise + sum
/// - pointer
/// - function args
/// - registering




// notes:

// rule syntax
// .rule args :
//     lhs -> rhs

// function convention
// .Cn [[mem, [args]], .Cn [mem, [outs]]]
// .Cn [[mem, [A, B, C]], .Cn [mem, [X, Y]]]