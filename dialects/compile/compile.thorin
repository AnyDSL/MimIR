/// # The compile dialect {#compile}
///
/// [TOC]
///
/// TODO
///
/// ## Types
///
/// ### %compile.Pass
/// ### %compile.Phase
/// 
/// Types for compilation passes and phases.
///
.ax %compile.Pass: *; 
.ax %compile.Phase: *; 
///
/// ### %compile.Pipeline
/// ### %compile.PassPhase
/// 
/// Types for functions that accept an arbitrary number of phases and passes respectively.
/// 
.Pi Pipeline: *, %compile.Phase = Pipeline;
.Pi PassPhase: *, %compile.Pass = PassPhase;
.Pi CombinedPhase: *, %compile.Phase = CombinedPhase;
///
/// ## Expressions
///
/// ### %compile.pipe
/// 
/// Given n phases, returns the representation of a pipeline.
///
.ax %compile.pipe: Pipeline;
///
/// ## Compilation Passes and Phases
///
/// ### %compile.debug_phase
/// 
/// Given a log level, returns a phase that prints the externals (for log level >= 2).
///
.ax %compile.debug_phase: .Nat -> %compile.Phase;
///
/// ### %compile.pass_phase
/// 
/// Given n passes, returns a phase that applies them in order.
///
.ax %compile.pass_list: PassPhase;
.ax %compile.pass_phase: PassPhase -> %compile.Phase, normalize_pass_phase;
.ax %compile.passes_to_phase: Π [n:.Nat] -> «n; %compile.Pass» -> %compile.Phase;
.ax %compile.single_pass_phase: %compile.Pass -> %compile.Phase, normalize_single_pass_phase;
///
/// ### %compile.combined_phase
/// 
/// Given n phases, returns a phase that applies them in order.
///
.ax %compile.phase_list: CombinedPhase;
.ax %compile.combined_phase: CombinedPhase -> %compile.Phase, normalize_combined_phase;
.ax %compile.phases_to_phase: Π [n:.Nat] -> «n; %compile.Phase» -> %compile.Phase;
///
/// ### Passes
/// 
/// TODO
///
.ax %compile.partial_eval_pass: %compile.Pass;
.ax %compile.beta_red_pass: %compile.Pass;
.ax %compile.eta_red_pass: %compile.Pass;
/// Eta expansion expects an instance of eta reduction as argument.
.ax %compile.eta_exp_pass: %compile.Pass -> %compile.Pass;
/// Scalerize expects an instance of eta expansion as argument.
.ax %compile.scalerize_pass: %compile.Pass -> %compile.Pass;
.ax %compile.scalerize_no_arg_pass: %compile.Pass;
/// Tail recursion elimination expects an instance of eta reduction as argument.
.ax %compile.tail_rec_elim_pass: %compile.Pass -> %compile.Pass;
.ax %compile.tail_rec_elim_no_arg_pass: %compile.Pass;
.ax %compile.lam_spec_pass: %compile.Pass;
.ax %compile.ret_wrap_pass: %compile.Pass;
///
/// ### Phases
/// 
// TODO: allow functions by inlining them first
.let optimization_phase = {
    .let eta_red = %compile.eta_red_pass;
    .let eta_exp = %compile.eta_exp_pass eta_red;
    %compile.pass_phase (%compile.pass_list
        %compile.partial_eval_pass
        %compile.beta_red_pass
        eta_red
        eta_exp
        (%compile.scalerize_pass eta_exp)
        (%compile.tail_rec_elim_pass eta_red)
    )
};
        
.let default_pipeline = {
    %compile.pipe
        (%compile.single_pass_phase %compile.scalerize_no_arg_pass)
        (%compile.single_pass_phase %compile.eta_red_pass)
        (%compile.single_pass_phase %compile.tail_rec_elim_no_arg_pass)
        optimization_phase
        (%compile.single_pass_phase %compile.lam_spec_pass)
        (%compile.single_pass_phase %compile.ret_wrap_pass)
};
