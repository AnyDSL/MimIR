#include "dialects/haskell/be/haskell_emit.h"

#include <deque>
#include <fstream>
#include <iomanip>
#include <limits>
#include <ranges>

#include "thorin/def.h"
#include "thorin/tuple.h"

#include "thorin/analyses/cfg.h"
#include "thorin/be/emitter.h"
#include "thorin/util/print.h"
#include "thorin/util/sys.h"

#include "dialects/core/core.h"
#include "dialects/math/math.h"
#include "dialects/mem/mem.h"

using namespace std::string_literals;

namespace thorin::haskell {

class BB {};

class Emitter : public thorin::Emitter<std::string, std::string, BB, Emitter> {
public:
    using Super = thorin::Emitter<std::string, std::string, BB, Emitter>;

    Emitter(World& w, std::ostream& ostream) //, const std::function<void(std::ostream&, const Def*)>& stream_def)
        : Super(w, "dot_emitter", ostream)
    // , stream_def_(stream_def)
    {
        ostream << "-- Some Prelude\n";
    }

    ~Emitter() {
        ostream_ << connections_.str();
        ostream_ << "\n";
    }

    bool is_valid(std::string_view s) { return !s.empty(); }
    void emit_imported(Lam*);
    void emit_epilogue(Lam*);

    void emit_var(const Var*);

    std::string emit_bb(BB&, const Def*);
    std::string prepare(const Scope&);
    void finalize(const Scope&);

private:
    std::function<void(std::ostream&, const Def*)> stream_def_;
    DefSet visited_noms_;
    std::ostringstream connections_;
};

void emit(World& world, std::ostream& ostream) {
    ostream << "-- Haskell code generated by Thorin" << std::endl;
    Emitter emitter(world, ostream);
    emitter.run();
}

void Emitter::emit_imported(Lam* lam) {
    // print(ostream_, "\"{}:{}\" [shape=rect];\n", lam->node_name(), lam->unique_name());
    print(ostream_, "Imported {} {}\n", lam->node_name(), lam->name());
}

void Emitter::emit_epilogue(Lam* lam) {
    if (visited_noms_.contains(lam)) return;
    visited_noms_.insert(lam);

    if (lam != entry_) {
        // emit_cluster_start(ostream_, lam);
        // print(ostream_, "Epilogue {} {}\n", lam->node_name(), lam->unique_name());
        print(ostream_, "  let {} ", lam->name());
        emit_var(lam->var());
        print(ostream_, " = \n");
        emit(lam->body());
        print(ostream_, "\n");
        // print(ostream_, "End Epilogue \n");
        print(ostream_, " in\n");
    } else {
        // top level function (header emitted)
        emit(lam->body());
    }
    // print(ostream_, "\n");
}

// body of functions
std::string Emitter::emit_bb(BB&, const Def* def) {
    // if (auto lam = def->isa<Lam>()) return lam->name();
    // TODO: cache expressions in let binding
    if (auto lam = def->isa<Lam>()) print(ostream_, "{}", lam->name());

    // print(ostream_, "Emit {} {}\n", def->node_name(), def->unique_name());

    // print(ostream_, "\"{}:{}\" [label=\"", def->node_name(), def->unique_name());
    // stream_def_(ostream_, def);
    // ostream_ << "\"";
    // // emit_node_attributes(ostream_, def);
    // ostream_ << "];\n";
    if (auto var = def->isa<Var>()) {
        emit_var(var);
    } else if (auto app = def->isa<App>()) {
        emit_unsafe(app->callee());
        print(ostream_, " ");
        emit(app->arg());

        // print(ostream_, "\n");
    } else if (auto ext = def->isa<Extract>()) {
        auto tuple = ext->tuple();
        if (tuple->type()->isa<Arr>()) {
            emit(tuple);
            print(ostream_, "!!");
            emit(ext->index());
            // print(ostream_, ".{}", ext->index());
        } else {
            // TODO:
        }
    } else if (auto tuple = def->isa<Tuple>()) {
        if (tuple->type()->isa<Arr>()) {
            print(ostream_, "[");
            for (auto i = 0; i < tuple->num_ops(); i++) {
                if (i > 0) print(ostream_, ", ");
                emit(tuple->op(i));
            }
            print(ostream_, "]");
        } else {
            // TODO:
        }
    } else {
        // TODO:
        // print(ostream_, "{}", def->unique_name());
        for (auto op : def->ops()) {
            // emit_unsafe(op);
            // print(connections_, "\"{}:{}\"->\"{}:{}\";\n", def->node_name(), def->unique_name(), op->node_name(),
            //       op->unique_name());
        }
    }

    return {def->unique_name()};
}

void Emitter::emit_var(const Var* def) {
    // assert(def->isa<Var>());

    // (arg1, arg2, arg3)
    print(ostream_, "{}", def->unique_name());
    // print(ostream_, "(");
    // auto num = def->num_projs();
    // for (nat_t i = 0; i < num; i++) {
    //     auto op = def->proj(num, i);
    //     print(ostream_, "{}", op->unique_name());
    //     if (i < num - 1) print(ostream_, ", ");
    // }
    // print(ostream_, ")");
}

// toplevel function
std::string Emitter::prepare(const Scope& scope) {
    auto lam = scope.entry()->as_nom<Lam>();

    // emit_cluster_start(ostream_, lam);
    // print(ostream_, "Prepare {} {}\n", lam->node_name(), lam->unique_name());
    // auto args = join(lam->var(), ", ", [](auto param) { return param->unique_name(); });
    // print(ostream_, "{} { } =\n", lam->unique_name(), args);
    // print(ostream_, "{} ... =\n", lam->unique_name());
    print(ostream_, "{} ", lam->name());
    // assert(lam->var());
    // world_.DLOG("Lam var: {} : {}", lam->var(), lam->var()->type());
    // print(ostream_, "...");
    // emit_unsafe(lam->var());
    // emit(lam->var());
    emit_var(lam->var());
    print(ostream_, " = \n");

    return lam->name();
}

void Emitter::finalize(const Scope&) { ostream_ << "\n"; }

} // namespace thorin::haskell
