/// # The matrix Dialect {#mat}
///
/// [TOC]
///
/// ## Dependencies
///
.import mem;
.import core;
///
/// ## Types
///
/// ### %matrix.Mat
///
/// a n-dimensional tensor with elements of type T
/// can be seen as generalization of Coq's vector type
///
/// matrix = Π [n: .Nat, S: «n; .Nat», T: *] -> *
/// matrix n S T = «Π_i=0^n S_i; T»
/// or 
/// matrix n S T = «S_0; «S_1; ... «S_{n-1}; T» ... »»
/// => a matrix is a dependend array
///
/// Alternative (current implementation):
/// matrix n S Ty = [i64, ..., i64, ptr(<T, Ty>)]
/// (currently with mem and as fat pointer without static size association:
///   [bit_field:i32, content:ptr(<T, Ty>), size_0:i64, size_1:i64])
/// * size: dependend vs i64 tuple
/// * shape: nested vs flat (n0*n1*...) elements
/// * mutability: mutable by nature vs mutable by its element type (liftet in thorin optimization / codegen)
///
/// advantage of opaque type for matrizes:
/// * prevent arbitrary read & insertions
/// 
/// depending on operations, one probably wants matrices to be a transparent definition instead of an opaque axiom
/// (currently: mat: [T: *] -> *)
.ax %matrix.Mat: Π [n: .Nat, S: «n; .Nat», T: *] -> *; 
///
/// ## Operations
///
/// ### %matrix.shape
/// 
/// gets the size along the i-th dimension
/// for a dependent matrix this is a simple projection
/// returns S(i)
///
/// normalization rules: 
/// * resolve shape calls at construction by replacing them with the size argument
.ax %matrix.shape:  Π [n: .Nat, S: «n; .Nat», T: *] -> [%matrix.Mat (n,S,T), i: .Idx n] -> .Nat, normalize_shape;
///
/// ### %matrix.prod
///
/// matrix product
/// takes a m*k matrix, a k*l matrix and returns the product, a m*l matrix
/// only defined on two-dimensional matrices
/// 
/// ### %matrix.map
///
/// unary elementwise operation
/// that lifts a function to the matrix level
/// f can not simply be T->P as thorin code is written in CPS
/// (currently (comment): Map: [dims: nat, in: *, out: *] -> [mat[] w] -> m64 w)
/// (currently: map: [mat_type: *, out_sigma: *, f_pi: *] -> [:mem, m: mat_type, f: f_ty] -> [:mem, out: out_sigma])
/// rewrite: 
/// - map on constant matrix
/// - parallel map without effect
/// - map combination
/// - map zipWith
/// 
/// ### %matrix.zip
///
/// binary elementwise operation
/// that lifts a binary function to the matrix level
/// same as map
/// rewrite: 
/// - zip on constant matrices
/// - parallel zip without effect
/// - zip combination
/// - zip with one side constant matrix
/// - meta_zip add zero m = m
/// (currently: hardcoded as matrix operations)
/// 
/// ### %matrix.fold
///
/// 
/// ### %matrix.const
///
/// a constant matrix
/// (currently: const i32 as bitfield)
.ax %matrix.constMat: Π [n: .Nat, S: «n; .Nat», T: *] -> [%mem.M,T] -> [%mem.M,%matrix.Mat (n,S,T)];
/// 
/// ### %matrix.transpose
///
/// transpose _ (m:@mat _ k*l T) : @mat _ l*k T
/// completely resolved during normalization and implicitely rewriting
/// (for instance: read(transpose m) (i,j) = read m (j,i))
///
/// transpose matrix
/// 
/// 
/// ### %matrix.id
///
/// id (k, m) : @mat _ (k,k) (Int m)
///
/// the idendity matrix
/// 
/// ### %matrix.read
///
/// read _ (mat, idx) : body_type
///
/// a access to an element of the matrix
/// (currently: arithmetic pointer access)
/// normalization:
/// * read(insert)
/// * read(const)
.ax %matrix.read: Π [n: .Nat, S: «n; .Nat», T: *] -> [%mem.M, %matrix.Mat (n,S,T), idx: «i: n; .Idx S#i»] -> [%mem.M,T], normalize_read;
/// 
/// ### %matrix.insert
///
/// insert (dims, sizes, type) (mat, idx, val) : mat
///
/// depending on matrix implementation needs mem monad
/// as it is implemented as write
/// for mutable body types, the monad should be liftet
/// implementation either as write or array insertion
/// normalization:
/// * with other inserts
/// * with initialization
.ax %matrix.insert: Π [n: .Nat, S: «n; .Nat», T: *] -> [%mem.M,%matrix.Mat (n,S,T), idx: «i: n; .Idx S#i», val: T] -> [%mem.M,%matrix.Mat (n,S,T)], normalize_insert;
///
/// ## Related operations
///
/// ### multiiter
///
/// iterated over n dimensions
/// takes:
/// * n: number of dimensions
/// * sizes: shape of the dimensions
/// * function: mem -> index -> mem
/// the function is taken in cps style
// .ax %matrix.multiiter: Π [n: .Nat, S: «n; .Nat»] -> 
//     .Cn[mem: %mem.M, body: .Cn[%mem.M, «i: n; .Idx (S#i)», .Cn[%mem.M]], .Cn[%mem.M]], normalize_multiiter;
///
/// ## Internal operations
/// 
/// ### %matrix.init
///
/// a fresh matrix 
.ax %matrix.init: Π [n: .Nat, S: «n; .Nat», %mem.M, T: *] -> [%mem.M,%matrix.Mat (n,S,T)];
///
/// ## Definitions and aliases
/// 
/// ### zero
// .lam .extern matrix_zero_int: Π [n: .Nat, S: «n; .Nat», m: .Nat] -> %matrix.Mat (n,S,(.Idx m)) = {
//     .tt,
//     %matrix.constMat (n,S,(.Idx m)) (0: (.Idx m))
// };
// .lam .extern matrix_zero: Π [n: .Nat, S: «n; .Nat», m: .Nat] -> %matrix.Mat (n,S,(%Real m)) = {
//     .tt,
//     %matrix.constMat (n,S,(%Real m)) (0: (%Real m))
// };
/// ### zip
///
/// zip A B = zipWith id A B
// .lam .extern zip: 
//     Π [n: .Nat, S: «n; .Nat», P: *, Q: *] -> 
//     [(%matrix.Mat(n,S,P)), (%matrix.Mat(n,S,Q))] -> 
//     %matrix.Mat(n,S,[P,Q]) = {
//     .tt,
//     .lam zipper: .Cn[mem: %mem.M, p: P, q: Q, ret: .Cn[%mem.M, [P,Q]]] = {
//         .tt,
//         ret (mem,(p,q))
//     };
//     .lam inner: 
//         Π [A: (%matrix.Mat(n,S,P)), B: (%matrix.Mat(n,S,Q))] -> 
//         %matrix.Mat(n,S,[P,Q]) = {
//         .tt,
//         %matrix.zipWith (n,S,P,Q,[P,Q]) (A,B,zipper)
//     };
//     inner
// };


/// ### fst, snd, split
// .lam .extern matrix_fst: 
//     Π [n: .Nat, S: «n; .Nat», P: *, Q: *] -> 
//     [M: (%matrix.Mat (n,S,[P,Q]))] -> 
//     %matrix.Mat (n,S,P) = {
//     .tt,
//     .lam fst : .Cn[mem: %mem.M, pq: [P,Q], ret: .Cn[%mem.M, P]] = {
//         .let (p,q) = pq;
//         ret (mem,p)
//     };
//     %matrix.map (n,S,[P,Q],P) (M,fst)
// };
// .lam .extern matrix_snd: 
//     Π [n: .Nat, S: «n; .Nat», P: *, Q: *] -> 
//     [M: (%matrix.Mat (n,S,[P,Q]))] -> 
//     %matrix.Mat (n,S,Q) = {
//     .tt,
//     .lam snd : .Cn[mem: %mem.M, pq: [P,Q], ret: .Cn[%mem.M, Q]] = {
//         .let (p,q) = pq;
//         ret (mem,q)
//     };
//     %matrix.map (n,S,[P,Q],Q) (M,snd)
// };
// .lam .extern matrix_split: 
//     Π [n: .Nat, S: «n; .Nat», P: *, Q: *] -> 
//     [M: (%matrix.Mat (n,S,[P,Q]))] -> 
//     [%matrix.Mat (n,S,P), %matrix.Mat (n,S,Q)] = {
//     .tt,
//     (
//         matrix_fst (n,S,[P,Q]) (M),
//         matrix_snd (n,S,[P,Q]) (M)
//     )
// };
///
/// ## Unfolding functions
/// 
/// ### product
/// 
/// 
/// ### map
/// 
/// 
/// ### multiiter
/// 
/*
let multiiter f n S:=
    let idx = <0: n>;
    let inner m :=
        if m = 0 then
            f (idx)
        else
            for ...
                (i -> 
                    insert (idx, m - 1) i;
                    inner (m - 1)
                )
*/
/// TODO:




// TODO:
// define alias:
// * fst, snd, split
// * zip = zipWith id
// .ax %matrix.id: Π [k: .Nat, m: .Nat] -> %matrix.Mat (2,(k,k),(.Idx m));
// .ax %matrix.transpose: Π [kl: «2: .Nat; .Nat», T: *] -> 
//     .let (k,l) = kl;
//     %matrix.Mat (2,(k,l),T) -> %matrix.Mat (2,(l,k),T), normalize_tranpose;
// .ax %matrix.fold:  Π [n: .Nat, S: «n; .Nat», T: *, P: *] -> [%matrix.Mat (n,S,T), accu: P, f: .Cn [%mem.M, P, T, .Cn [%mem.M, P] ] ] -> P, normalize_fold;
// .ax %matrix.zipWith:  Π [n: .Nat, S: «n; .Nat», P: *, Q: *, R: *] -> [%matrix.Mat(n,S,P), %matrix.Mat(n,S,Q), f: .Cn [%mem.M, P, Q, .Cn [%mem.M, R] ] ] -> %matrix.Mat(n,S,R), normalize_zip;
// .ax %matrix.parallel_zip:  Π [n: .Nat, S: «n; .Nat», P: *, Q: *, R: *] -> [%matrix.Mat n S P, %matrix.Mat n S Q, f: .Cn [P, Q, .Cn [R] ] ] -> %matrix.Mat n S R, normalize_parallel_zip;
// .ax %matrix.meta_zip:  Π [n: .Nat, S: «n; .Nat», P: *, Q: *, R: *] -> [%matrix.Mat n S P, %matrix.Mat n S Q, f: P -> Q -> R ] -> %matrix.Mat n S R, normalize_meta_zip;
// .ax %matrix.map:  Π [n: .Nat, S: «n; .Nat», T: *, P: *] -> [%matrix.Mat (n,S,T), f: .Cn [%mem.M, T, .Cn [%mem.M, P] ] ] -> %matrix.Mat (n,S,P), normalize_map;
// .ax %matrix.parallel_map:  Π [n: .Nat, S: «n; .Nat», T: *, P: *] -> [%matrix.Mat n S T, f: .Cn [T, .Cn [P] ] ] -> %matrix.Mat n S P, normalize_parallel_map;
// .ax %matrix.meta_map:  Π [n: .Nat, S: «n; .Nat», T: *, P: *] -> [%matrix.Mat n S T, f: T -> P ] -> %matrix.Mat n S P, normalize_meta_map;
// .ax %matrix.prod:  Π [m: .Nat, k: .Nat, l: .Nat, w: .Nat] -> [%matrix.Mat (2,(m, k),%Real w), %matrix.Mat (2,(k, l),%Real w)] -> %matrix.Mat (2,(m, l),%Real w), normalize_prod;
.ax %matrix.prod:  Π [m: .Nat, k: .Nat, l: .Nat, w: .Nat] -> [%matrix.Mat (2,(m, k),%core.Real w), %matrix.Mat (2,(k, l),%core.Real w)] -> %matrix.Mat (2,(m, l),%core.Real w), normalize_prod;
.ax %matrix.transpose: Π [kl: «2: .Nat; .Nat», T: *] -> 
    .let (k,l) = kl;
    %matrix.Mat (2,(k,l),T) -> %matrix.Mat (2,(l,k),T), normalize_transpose;

// .ax %matrix.sum: Π [n: .Nat, S: «n; .Nat», T: *] -> [%mem.M,%matrix.Mat (n,S,T)] -> [%mem.M,T];
.ax %matrix.sum: Π [n: .Nat, S: «n; .Nat», w:.Nat] -> [%mem.M,%matrix.Mat (n,S,%core.Real w)] -> [%mem.M,%core.Real w];


// TODO: handle reduction case
//  n=0, S=[] => not empty but scalar

// inspired by einsum
// reference:
// * Tensorflow / XLA: einsum
// * Pytorch: einsum
// * NumPy: einsum
// * Halide
// * Haskell: Tensor DSL
// * Ricci Calculus
// * Einstein Notation
// * Pytorch DSL
// https://optimized-einsum.readthedocs.io/en/stable/

// mapReduce application:
// * einsum(idx, MatrixIndices) = mapReduce(0,+,product,MatrixIndices)
// * map f M = mapReduce (0,+,f,[(idx,M)])  [TODO: get rid of reduce step if not needed with dummy values]
// * reduce acc f M = mapReduce (n=0) (acc,f,id,[(idx,M)])  [TODO: see index problem above]
// einsum application:
// * tranpose ij->ji  (einsum(,[(1,0),M]))
// * trace ii->
// * sum ij ->
// * col sum ij -> j 
// * mat vec prod ik,k->i
// * mat mat prod ik,kj -> ij
// * dot product i,i ->
// * dot matrix ij,ij ->
// * outer product i,j -> ij

// TODO: introduce dummies
// dummy = has correct type but can not produce code (should always be eliminated)
// .ax %matrix.mapReduce: 
//     // out shape depends on in shape but is complex
//     Π [n: .Nat, S: «n; .Nat», T: *, // out shape
//         m: .Nat, // number of inputs
//         NI: «m; .Nat», // input dimensions
//         TI: «m; *», // input types
//         SI: «i:m; «NI#i; .Nat»» // input shapes
//     ] -> 
//     // main arguments
//     [
//         mem: %mem.M, // memory
//         zero: T, // initial value
//         add: [T,T]->T, // reduction operation
//         mul: [%mem.M,TI]->[%mem.M,T], // inner combination
//         // out_index not needed => always ij (0 ... n) for n dimensions
//         input:
//             «i:m; 
//                 [
//                     «NI#i;.Nat»,
//                     %matrix.Mat (NI#i,SI#i,TI#i)
//                 ]
//             »
//     ] ->
//     [%mem.M, %matrix.Mat (n,S,T)],
//     normalize_mapReduce;

// .lam .extern snd 
//     Π [T:*] -> [a:T,b:T] -> T = {.tt, b};
// .ax %matrix.dummyZero: Π [T:*] -> T;
// .let dummyAdd = snd;


// .let I32 = .Idx 4294967296;
// .let TT = I32;
// .let test = %matrix.mapReduce 
//         (2,(4,3),I32,
//             2,
//             (2,3),
//             (I32,I32), // <2;I32>
//             (
//                 (0,1),
//                 (1,0,1)
//             )
//         );


// .lam .extern transpose:
//     Π [kl: «2: .Nat; .Nat»] ->
//     .let (k,l) = kl;
//     %matrix.Mat (2,(k,l),TT) -> %matrix.Mat (2,(l,k),TT) = {
//     .tt,
//     .let (k,l) = kl;
//     .lam transpose_curry :
//         [M:%matrix.Mat (2,(k,l),TT)] -> %matrix.Mat (2,(l,k),TT) = {
//         .tt,
//         %matrix.mapReduce 
//             (
//                 2, (l,k), TT, 
//                 2,
//                 <1;2>,
//                 <1;TT>,
//                 // <1;(k,l)>
//                 (k,l)
//                 // (2,2),
//                 // (TT,TT),
//                 // ((k,l),(k,l))
//             )
//     };
//     transpose_curry
// };

/*
* wishes for dialects (not all are sensible):

Needed:
* - better error messages (:4294967295: error: symbol 'n' already declared in the current scope here: :4294967295)
* - a : .Idx 5 should be a : (.Idx 5) and not (a : .Idx) 5
* - currying syntax

WIP:
* - transparent definitions
* - holes 

Not necessarily needed:
* - type inference ([m, k] above) if not already possible (subsumed by infer)
* - dependend destruct pattern [[k:.Nat, l:.Nat], T:*] (done by using lets)
* - autoquantification / Variable environment

* other points:
* - the parallel (mem free) version and the meta version (or the other way around)
*   should be automatically derivable from the other version
* - do not tell the name of the domain type but the type definition
*/




// .lam .extern matrix_map_unfold: 
//     Π [n: .Nat, S: «n; .Nat», P: *, Q: *] -> 
//     [%matrix.Mat (n,S,T), f: .Cn [%mem.M, T, .Cn [%mem.M, P] ] ] -> %matrix.Mat (n,S,P) = {
//     .tt,
//     .lam .extern matrix_map_unfold_curry: 
//         Π [%matrix.Mat (n,S,T), f: .Cn [%mem.M, T, .Cn [%mem.M, P] ] ] -> 
//         %matrix.Mat (n,S,P) = {
//         .tt,

        


//     };
//     matrix_map_unfold_curry
// };
