/// # The matrix Dialect {#mat}
///
/// [TOC]
///
/// ## Types
///
/// ### :mat.Mat
///
/// a n-dimensional tensor with elements of type T
/// can be seen as generalization of Coq's vector type
///
/// matrix = Π [n: .Nat, S: «n; .Nat», T: *] -> *
/// matrix n S T = «Π_i=0^n S_i; T»
/// or 
/// matrix n S T = «S_0; «S_1; ... «S_{n-1}; T» ... »»
/// => a matrix is a dependend array
///
/// Alternative (current implementation):
/// matrix n S Ty = [i64, ..., i64, ptr(<T, Ty>)]
/// (currently with mem and as fat pointer without static size association:
///   [bit_field:i32, content:ptr(<T, Ty>), size_0:i64, size_1:i64])
/// * size: dependend vs i64 tuple
/// * shape: nested vs flat (n0*n1*...) elements
/// * mutability: mutable by nature vs mutable by its element type (liftet in thorin optimization / codegen)
///
/// advantage of opaque type for matrizes:
/// * prevent arbitrary read & insertions
/// 
/// depending on operations, one probably wants matrices to be a transparent definition instead of an opaque axiom
/// (currently: mat: [T: *] -> *)
.ax :mat.Mat: Π [n: .Nat, S: «n; .Nat», T: *] -> *; 
///
/// ## Operations
///
/// ### :mat.shape
/// 
/// gets the size along the i-th dimension
/// for a dependent matrix this is a simple projection
/// returns S(i)
///
/// normalization rules: 
/// * resolve shape calls at construction by replacing them with the size argument
.ax :mat.shape:  Π [n: .Nat, S: «n; .Nat», T: *] -> T, normalize_shape;
// .ax :mat.shape:  Π [n: .Nat, S: «n; .Nat», T: *] -> [:mat.Mat (n,S) T, i: :Int n] -> T, normalize_shape;
///
/// ### :mat.prod
///
/// matrix product
/// takes a m*k matrix, a k*l matrix and returns the product, a m*l matrix
/// only defined on two-dimensional matrices
// .ax :mat.prod:  Π [m: .Nat, k: .Nat, l: .Nat, T: *] -> [:mat.Mat (2,(m, k)) T, :mat.Mat (2,[k, l]) T] -> :mat.Mat 2 [m, l] T, normalize_prod;
/// 
/// ### :mat.map
///
/// unary elementwise operation
/// that lifts a function to the matrix level
/// f can not simply be T->P as thorin code is written in CPS
/// (currently (comment): Map: [dims: nat, in: *, out: *] -> [mat[] w] -> m64 w)
/// (currently: map: [mat_type: *, out_sigma: *, f_pi: *] -> [:mem, m: mat_type, f: f_ty] -> [:mem, out: out_sigma])
/// rewrite: 
/// - map on constant matrix
/// - parallel map without effect
/// - map combination
// .ax :mat.map:  Π [n: .Nat, S: «n; .Nat», T: *, P: *] -> [:mat.Mat n S T, f: .Cn [%mem.M, T, .Cn [%mem.M, P] ] ] -> :mat.Mat n S P, normalize_map;
// .ax :mat.parallel_map:  Π [n: .Nat, S: «n; .Nat», T: *, P: *] -> [:mat.Mat n S T, f: .Cn [T, .Cn [P] ] ] -> :mat.Mat n S P, normalize_parallel_map;
// .ax :mat.meta_map:  Π [n: .Nat, S: «n; .Nat», T: *, P: *] -> [:mat.Mat n S T, f: T -> P ] -> :mat.Mat n S P, normalize_meta_map;
/// 
/// ### :mat.zip
///
/// binary elementwise operation
/// that lifts a binary function to the matrix level
/// same as map
/// rewrite: 
/// - zip on constant matrices
/// - parallel zip without effect
/// - zip combination
/// - zip with one side constant matrix
/// - meta_zip add zero m = m
/// (currently: hardcoded as matrix operations)
// .ax :mat.zip:  Π [n: .Nat, S: «n; .Nat», P: *, Q: *, R: *] -> [:mat.Mat n S P, :mat.Mat n S Q, f: .Cn [%mem.M, P, Q, .Cn [%mem.M, R] ] ] -> :mat.Mat n S R, normalize_zip;
// .ax :mat.parallel_zip:  Π [n: .Nat, S: «n; .Nat», P: *, Q: *, R: *] -> [:mat.Mat n S P, :mat.Mat n S Q, f: .Cn [P, Q, .Cn [R] ] ] -> :mat.Mat n S R, normalize_parallel_zip;
// .ax :mat.meta_zip:  Π [n: .Nat, S: «n; .Nat», P: *, Q: *, R: *] -> [:mat.Mat n S P, :mat.Mat n S Q, f: P -> Q -> R ] -> :mat.Mat n S R, normalize_meta_zip;
///
/// ### :mat.zero
///
/// a constant zero matrix
/// (currently: const i32 as bitfield)
// .ax :mat.zero: Π [n: .Nat, S: «n; .Nat», m: .Nat] -> :mat.Mat n S (:Int m), normalize_zero;
/// 
/// ### :mat.const
///
/// a constant matrix
/// (currently: const i32 as bitfield)
// .ax :mat.const: Π [n: .Nat, S: «n; .Nat», T: *] -> t: T -> :mat.Mat n S T, normalize_const;
/// 
/// ### :mat.read
///
/// a access to an element of the matrix
/// (currently: arithmetic pointer access)
// .ax :mat.read: Π [n: .Nat, S: «n; .Nat», T: *] -> [:mat.Mat n S T, idx: «i: n; :Int S#i»] -> T, normalize_read;
/// 
/// ### :mat.insert
///
/// depending on matrix implementation needs mem monad
/// as it is implemented as write
/// for mutable body types, the monad should be liftet
/// implementation either as write or array insertion
/// normalization:
/// * with other inserts
/// * with initialization
// .ax :mat.insert: Π [n: .Nat, S: «n; .Nat», T: *] -> [:mat.Mat n S T, idx: «i: n; :Int S#i», val: T] -> :mat.Mat n S T, normalize_insert;


/*
* wishes for dialects (not all are sensible):
* - transparent definitions
* - holes (wip)
* - autoquantification / Variable environment
* - powerful parser
* - type inference ([m, k] above) if not already possible
* - better error messages (:4294967295: error: symbol 'n' already declared in the current scope here: :4294967295)
* other points:
* - the parallel (mem free) version and the meta version (or the other way around)
*   should be automatically derivable from the other version
*/