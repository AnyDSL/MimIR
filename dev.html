<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thorin: Developer Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-interactive-toc.js" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/anydsl/thorin2" class="github-corner" title="View source on GitHub">
    <svg viewBox="0 0 250 250" style="position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Thorin<span id="projectnumber">&#160;1.9.0</span>
   </div>
   <div id="projectbrief">The Higher ORder INtermediate representation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dev.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Developer Guide </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md15">Basics</a></li>
<li class="level1"><a href="#mut">Immutables vs. Mutables</a></li>
<li class="level1"><a href="#autotoc_md16">Matching IR</a><ul><li class="level2"><a href="#cast_builtin">Upcast for Built-ins</a><ul><li class="level3"><a href="#autotoc_md17">Upcast</a></li>
<li class="level3"><a href="#autotoc_md18">Upcast for Immutables</a></li>
<li class="level3"><a href="#autotoc_md19">Upcast for Mutables</a></li>
<li class="level3"><a href="#cast_lit">Matching Literals</a></li>
<li class="level3"><a href="#autotoc_md20">Summary</a></li>
<li class="level3"><a href="#autotoc_md21">Further Casts</a></li>
</ul>
</li>
<li class="level2"><a href="#cast_axiom">Matching Axioms</a><ul><li class="level3"><a href="#autotoc_md22">w/o Subtags</a></li>
<li class="level3"><a href="#autotoc_md23">w/ Subtags</a></li>
<li class="level3"><a href="#autotoc_md24">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md25">Working with Indices</a><ul><li class="level2"><a href="#autotoc_md26">Arity</a></li>
<li class="level2"><a href="#autotoc_md27">Proj</a></li>
<li class="level2"><a href="#autotoc_md28">Shape</a></li>
<li class="level2"><a href="#autotoc_md29">Summary</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md30">Iterating over the Program</a></li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_docs_dev"></a></p>
<p >This guide summaries typical idioms you want to use when working with Thorin as a developer.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Basics</h1>
<p >Let's jump straight into an example. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mem_8h.html">dialects/mem/mem.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="driver_8h.html">thorin/driver.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parser_8h.html">thorin/fe/parser.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimize_8h.html">thorin/pass/optimize.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sys_8h.html">thorin/util/sys.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mem_2autogen_8h.html">dialects/mem/autogen.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacethorin.html">thorin</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code hl_class" href="classthorin_1_1Driver.html">Driver</a> driver;</div>
<div class="line">        <span class="keyword">auto</span>&amp; world = driver.<a class="code hl_function" href="classthorin_1_1Driver.html#a49bf53fc0f6930391779ef722713c57e">world</a>();</div>
<div class="line">        driver.<a class="code hl_function" href="classthorin_1_1Driver.html#a591d82f03685b27cbfd9e1ab549d3648">log</a>().<a class="code hl_function" href="classthorin_1_1Log.html#af05569443ced1196eac9043970e8f64c">set</a>(&amp;std::cerr).<a class="code hl_function" href="classthorin_1_1Log.html#af05569443ced1196eac9043970e8f64c">set</a>(Log::Level::Debug);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> parser = <a class="code hl_class" href="classthorin_1_1fe_1_1Parser.html">fe::Parser</a>(world);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> plugin : {<span class="stringliteral">&quot;compile&quot;</span>, <span class="stringliteral">&quot;core&quot;</span>}) parser.plugin(plugin);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// .Cn [%mem.M, I32, %mem.Ptr (I32, 0) .Cn [%mem.M, I32]]</span></div>
<div class="line">        <span class="keyword">auto</span> mem_t  = world.annex&lt;<a class="code hl_enumeration" href="namespacethorin_1_1mem.html#abab7091b7bb05e14f8f9e7081981fb7c">mem::M</a>&gt;();</div>
<div class="line">        <span class="keyword">auto</span> i32_t  = world.type_int(32);</div>
<div class="line">        <span class="keyword">auto</span> argv_t = world.call&lt;<a class="code hl_enumeration" href="namespacethorin_1_1mem.html#ab05fd1ac51371ea3ad809a2aa00722da">mem::Ptr0</a>&gt;(world.call&lt;<a class="code hl_enumeration" href="namespacethorin_1_1mem.html#ab05fd1ac51371ea3ad809a2aa00722da">mem::Ptr0</a>&gt;(i32_t));</div>
<div class="line">        <span class="keyword">auto</span> ret_t  = world.cn({mem_t, i32_t});</div>
<div class="line">        <span class="keyword">auto</span> main_t = world.cn({mem_t, i32_t, argv_t, ret_t});</div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_function" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>   = world.mut_lam(main_t)-&gt;set(<span class="stringliteral">&quot;main&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> [mem, argc, argv, <a class="code hl_enumvalue" href="namespacethorin_1_1clos.html#a5c55a5bd62132e28b49915902ea0117aa2348b9af292e8373483f8ff836d5aac2">ret</a>] = <a class="code hl_function" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>-&gt;vars&lt;4&gt;();</div>
<div class="line">        <a class="code hl_function" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>-&gt;app(<span class="keyword">false</span>, ret, {mem, argc});</div>
<div class="line">        <a class="code hl_function" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>-&gt;make_external();</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="namespacethorin.html#a9e64c2e92ce1a1166c536644960116c2">optimize</a>(world);</div>
<div class="line">        std::ofstream ofs(<span class="stringliteral">&quot;hello.ll&quot;</span>);</div>
<div class="line">        driver.<a class="code hl_function" href="classthorin_1_1Driver.html#aa6cbf574516649c25fc161aad036e295">backend</a>(<span class="stringliteral">&quot;ll&quot;</span>)(world, ofs);</div>
<div class="line">        ofs.close(); <span class="comment">// make sure everything is written before clang is invoked</span></div>
<div class="line"> </div>
<div class="line">        sys::system(<span class="stringliteral">&quot;clang hello.ll -o hello -Wno-override-module&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="namespacethorin.html#af7ec5537fa7b52e17905ef114e40a765">outln</a>(<span class="stringliteral">&quot;exit code: {}&quot;</span>, sys::system(<span class="stringliteral">&quot;./hello a b c&quot;</span>));</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        <a class="code hl_function" href="namespacethorin.html#a01d195c52d754394a58dec37e2913430">errln</a>(<span class="stringliteral">&quot;{}&quot;</span>, <a class="code hl_enumvalue" href="namespacethorin_1_1core.html#afab2045241ef2b508a0c6867099991e6a2617461720290be8740985537e6e1bfd">e</a>.what());</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <a class="code hl_function" href="namespacethorin.html#a01d195c52d754394a58dec37e2913430">errln</a>(<span class="stringliteral">&quot;error: unknown exception&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassthorin_1_1Driver_html"><div class="ttname"><a href="classthorin_1_1Driver.html">thorin::Driver</a></div><div class="ttdoc">Some &quot;global&quot; variables needed all over the place.</div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00017">driver.h:17</a></div></div>
<div class="ttc" id="aclassthorin_1_1Driver_html_a49bf53fc0f6930391779ef722713c57e"><div class="ttname"><a href="classthorin_1_1Driver.html#a49bf53fc0f6930391779ef722713c57e">thorin::Driver::world</a></div><div class="ttdeci">World &amp; world()</div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00025">driver.h:25</a></div></div>
<div class="ttc" id="aclassthorin_1_1Driver_html_a591d82f03685b27cbfd9e1ab549d3648"><div class="ttname"><a href="classthorin_1_1Driver.html#a591d82f03685b27cbfd9e1ab549d3648">thorin::Driver::log</a></div><div class="ttdeci">Log &amp; log()</div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00024">driver.h:24</a></div></div>
<div class="ttc" id="aclassthorin_1_1Driver_html_aa6cbf574516649c25fc161aad036e295"><div class="ttname"><a href="classthorin_1_1Driver.html#aa6cbf574516649c25fc161aad036e295">thorin::Driver::backend</a></div><div class="ttdeci">auto backend(std::string_view name)</div><div class="ttdef"><b>Definition:</b> <a href="driver_8h_source.html#l00069">driver.h:69</a></div></div>
<div class="ttc" id="aclassthorin_1_1Log_html_af05569443ced1196eac9043970e8f64c"><div class="ttname"><a href="classthorin_1_1Log.html#af05569443ced1196eac9043970e8f64c">thorin::Log::set</a></div><div class="ttdeci">Log &amp; set(std::ostream *ostream)</div><div class="ttdef"><b>Definition:</b> <a href="log_8h_source.html#l00034">log.h:34</a></div></div>
<div class="ttc" id="aclassthorin_1_1fe_1_1Parser_html"><div class="ttname"><a href="classthorin_1_1fe_1_1Parser.html">thorin::fe::Parser</a></div><div class="ttdoc">Parses Thorin code into the provided World.</div><div class="ttdef"><b>Definition:</b> <a href="parser_8h_source.html#l00029">parser.h:29</a></div></div>
<div class="ttc" id="adriver_8h_html"><div class="ttname"><a href="driver_8h.html">driver.h</a></div></div>
<div class="ttc" id="amain_8cpp_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> <a href="main_8cpp_source.html#l00025">main.cpp:25</a></div></div>
<div class="ttc" id="amem_2autogen_8h_html"><div class="ttname"><a href="mem_2autogen_8h.html">autogen.h</a></div></div>
<div class="ttc" id="amem_8h_html"><div class="ttname"><a href="mem_8h.html">mem.h</a></div></div>
<div class="ttc" id="anamespacethorin_1_1clos_html_a5c55a5bd62132e28b49915902ea0117aa2348b9af292e8373483f8ff836d5aac2"><div class="ttname"><a href="namespacethorin_1_1clos.html#a5c55a5bd62132e28b49915902ea0117aa2348b9af292e8373483f8ff836d5aac2">thorin::clos::ret</a></div><div class="ttdeci">@ ret</div><div class="ttdef"><b>Definition:</b> <a href="clos_2autogen_8h_source.html#l00063">autogen.h:63</a></div></div>
<div class="ttc" id="anamespacethorin_1_1core_html_afab2045241ef2b508a0c6867099991e6a2617461720290be8740985537e6e1bfd"><div class="ttname"><a href="namespacethorin_1_1core.html#afab2045241ef2b508a0c6867099991e6a2617461720290be8740985537e6e1bfd">thorin::core::e</a></div><div class="ttdeci">@ e</div><div class="ttdef"><b>Definition:</b> <a href="core_2autogen_8h_source.html#l00150">autogen.h:150</a></div></div>
<div class="ttc" id="anamespacethorin_1_1mem_html_ab05fd1ac51371ea3ad809a2aa00722da"><div class="ttname"><a href="namespacethorin_1_1mem.html#ab05fd1ac51371ea3ad809a2aa00722da">thorin::mem::Ptr0</a></div><div class="ttdeci">Ptr0</div><div class="ttdef"><b>Definition:</b> <a href="mem_2autogen_8h_source.html#l00037">autogen.h:37</a></div></div>
<div class="ttc" id="anamespacethorin_1_1mem_html_abab7091b7bb05e14f8f9e7081981fb7c"><div class="ttname"><a href="namespacethorin_1_1mem.html#abab7091b7bb05e14f8f9e7081981fb7c">thorin::mem::M</a></div><div class="ttdeci">M</div><div class="ttdef"><b>Definition:</b> <a href="mem_2autogen_8h_source.html#l00015">autogen.h:15</a></div></div>
<div class="ttc" id="anamespacethorin_html"><div class="ttname"><a href="namespacethorin.html">thorin</a></div><div class="ttdef"><b>Definition:</b> <a href="affine_8h_source.html#l00007">affine.h:7</a></div></div>
<div class="ttc" id="anamespacethorin_html_a01d195c52d754394a58dec37e2913430"><div class="ttname"><a href="namespacethorin.html#a01d195c52d754394a58dec37e2913430">thorin::errln</a></div><div class="ttdeci">std::ostream &amp; errln(const char *fmt, Args &amp;&amp;... args)</div><div class="ttdef"><b>Definition:</b> <a href="print_8h_source.html#l00179">print.h:179</a></div></div>
<div class="ttc" id="anamespacethorin_html_a9e64c2e92ce1a1166c536644960116c2"><div class="ttname"><a href="namespacethorin.html#a9e64c2e92ce1a1166c536644960116c2">thorin::optimize</a></div><div class="ttdeci">void optimize(World &amp;world)</div><div class="ttdef"><b>Definition:</b> <a href="optimize_8cpp_source.html#l00019">optimize.cpp:19</a></div></div>
<div class="ttc" id="anamespacethorin_html_af7ec5537fa7b52e17905ef114e40a765"><div class="ttname"><a href="namespacethorin.html#af7ec5537fa7b52e17905ef114e40a765">thorin::outln</a></div><div class="ttdeci">std::ostream &amp; outln(const char *fmt, Args &amp;&amp;... args)</div><div class="ttdef"><b>Definition:</b> <a href="print_8h_source.html#l00178">print.h:178</a></div></div>
<div class="ttc" id="aoptimize_8h_html"><div class="ttname"><a href="optimize_8h.html">optimize.h</a></div></div>
<div class="ttc" id="aparser_8h_html"><div class="ttname"><a href="parser_8h.html">parser.h</a></div></div>
<div class="ttc" id="asys_8h_html"><div class="ttname"><a href="sys_8h.html">sys.h</a></div></div>
</div><!-- fragment --><p ><a class="el" href="classthorin_1_1Driver.html">Driver</a> is the first class that you want to allocate. It keeps track of a few "global" variables like some <a class="el" href="namespacethorin.html#structthorin_1_1Flags">Flags</a> or the <a class="el" href="classthorin_1_1Log.html">Log</a>. Here, the log is set up to output to <code>std::cerr</code> with <a class="el" href="classthorin_1_1Log.html#ae8ff4129d521840f869d27c15ead3a1aaa603905470e2a5b8c13e96b579ef0dba">thorin::Log::Level::Debug</a> (see also <a class="el" href="cli.html#clidebug">Debugging Features</a>).</p>
<p >Then, we load the plugins <a class="el" href="compile.html">compile</a> and <a class="el" href="core.html">core</a>, which in turn will load the plugin <a class="el" href="mem.html">mem</a>. A plugin consists of a shared object (<code>.so</code>/<code>.dll</code>) and a <code>.thorin</code> file. The shared object contains <a class="el" href="classthorin_1_1Pass.html">Passes</a>, <a class="el" href="classthorin_1_1Axiom.html#a05d2e899a18e55005f71c1803da89ae3">normalizers</a>, and so on. The <code>.thorin</code> file contains the <a class="el" href="classthorin_1_1Axiom.html">axiom</a> declarations and links the normalizers with the <a class="el" href="classthorin_1_1Axiom.html">axioms</a>. For this reason, we need to allocate the <a class="el" href="classthorin_1_1fe_1_1Parser.html" title="Parses Thorin code into the provided World.">thorin::fe::Parser</a> to parse the <code>.thorin</code> file; <a class="el" href="classthorin_1_1fe_1_1Parser.html#af00d3ef719229d078fc93b46a859989b">thorin::fe::Parser::plugin</a> will also load the shared object. The <a class="el" href="classthorin_1_1Driver.html">driver</a> keeps track of all plugins.</p>
<p >Next, we create actual code. <a class="el" href="classthorin_1_1Def.html">Def</a> is the base class for <b>all</b> nodes/expressions in Thorin. Each <a class="el" href="classthorin_1_1Def.html">Def</a> is a node in a graph which is maintained in the <a class="el" href="classthorin_1_1World.html">World</a>. The <a class="el" href="classthorin_1_1World.html">World</a> is essentially a big hash set where all <a class="el" href="classthorin_1_1Def.html">Defs</a> are tossed into. The <a class="el" href="classthorin_1_1World.html">World</a> provides factory methods to create all kind of different <a class="el" href="classthorin_1_1Def.html">Defs</a>. Here, we create the <code>main</code> function. In direct style, its type looks like this: </p><div class="fragment"><div class="line">[%mem.M, I32, %mem.Ptr (I32, 0)] -&gt; [%mem.M, I32]]</div>
</div><!-- fragment --><p> Converted to <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">continuation-passing style (CPS)</a> this type looks like this: </p><div class="fragment"><div class="line">.Cn [%mem.M, I32, %mem.Ptr (I32, 0), .Cn [%mem.M, I32]]</div>
</div><!-- fragment --><p> The <code>%mem.M</code> type is a type that keeps track of side effects that may occur. Since, <code>main</code> introduces <a class="el" href="classthorin_1_1Var.html">Var</a>iables we must create a <b>mutable</b> <a class="el" href="classthorin_1_1Lam.html">Lam</a>bda (see <a class="el" href="dev.html#mut">Immutables vs. Mutables</a>). The only thing <code>main</code> is doing, is to invoke its <code>ret</code>urn continuation with <code>mem</code> and <code>argc</code> as argument: </p><div class="fragment"><div class="line">ret (mem, argc)</div>
</div><!-- fragment --><p> It is also important to make <code>main</code> <a class="el" href="classthorin_1_1Def.html#a0478725100ec49c9cb03ae02864a78d6">external</a>. Otherwise, Thorin will simply remove this function.</p>
<p >We <a class="el" href="namespacethorin.html#a9e64c2e92ce1a1166c536644960116c2">optimize</a> the program, emit an <a href="https://llvm.org/docs/LangRef.html">LLVM assembly file</a>, and compile it <a class="el" href="namespacethorin_1_1sys.html#a932508f0d5bde98eb7127e4f2533776f">via</a> <code>clang</code>. Finally, we <a class="el" href="namespacethorin_1_1sys.html#a932508f0d5bde98eb7127e4f2533776f">execute</a> the generated program with <code>./hello a b c</code> and <a class="el" href="namespacethorin.html#fmt">output</a> its exit code - which should be <code>4</code>.</p>
<h1><a class="anchor" id="mut"></a>
Immutables vs. Mutables</h1>
<p >There are two different kind of <a class="el" href="classthorin_1_1Def.html">Defs</a> in Thorin: <em>mutables</em> and <em>immutables</em>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>Immutable</b>   </th><th class="markdownTableHeadNone"><b>Mutable</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><em>must be</em> <code>const</code>   </td><td class="markdownTableBodyNone"><em>may be</em> <b>non</b>-<code>const</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ops form <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>   </td><td class="markdownTableBodyNone">ops may be cyclic    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">no recursion   </td><td class="markdownTableBodyNone">may be recursive    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">no <a class="el" href="classthorin_1_1Var.html">Var</a>   </td><td class="markdownTableBodyNone">has <a class="el" href="classthorin_1_1Var.html">Var</a>; get with <a class="el" href="classthorin_1_1Def.html#a22a6f98101cae5022aaa945031867e5c">Def::var</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">build ops first, then the actual node   </td><td class="markdownTableBodyNone">build the actual node first, then <a class="el" href="classthorin_1_1Def.html#af401dbc2a8092cdc438507614174f792">set</a> the ops    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Hash_consing">Hash consed</a>   </td><td class="markdownTableBodyNone">each new instance is fresh    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Def.html#aa4b459f1761e0ea7ddb9ec3629882cd7">Def::rebuild</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Def.html#ace93ea7b5a229237d0092b8ecab7d24a">Def::stub</a>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md16"></a>
Matching IR</h1>
<p >Thorin provides different means to scrutinize <a class="el" href="classthorin_1_1Def.html">Defs</a>. Usually, you will encounter a <a class="el" href="classthorin_1_1Def.html">Def</a> as <a class="el" href="classthorin_1_1Ref.html">Ref</a> which is just a wrapper for a <code>const Def*</code>. Its purpose is to resolve "holes" (called <em><a class="el" href="classthorin_1_1Infer.html">Infer</a>s</em> in Thorin) that may pop up due to type inference. Matching built-ins, i.e. all subclasses of <a class="el" href="classthorin_1_1Def.html">Def</a>, works differently than matching <a class="el" href="classthorin_1_1Axiom.html">Axiom</a>s.</p>
<h2><a class="anchor" id="cast_builtin"></a>
Upcast for Built-ins</h2>
<p >Methods beginning with</p><ul>
<li><code>isa</code> work like a <code>dynamic_cast</code> with a runtime check and return <code>nullptr</code> if the cast is not possible, while</li>
<li>those beginning with <code>as</code> are more like a <code>static_cast</code> and <code>assert</code> via its <code>isa</code> sibling in the <code>Debug</code> build that the cast is correct.</li>
</ul>
<h3><a class="anchor" id="autotoc_md17"></a>
Upcast</h3>
<p ><a class="el" href="classthorin_1_1RuntimeCast.html#a9b3aab7e1699f26e91e8675de9c0b202">Def::isa</a>/<a class="el" href="classthorin_1_1RuntimeCast.html#a909777be7f178004b0cca5ec68356c4c">Def::as</a> allows for an <em>upcast</em> that matches both <em>mutables</em> and <em>immutables</em>: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classthorin_1_1Ref.html">Ref</a> def) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> sigma = def-&gt;<a class="code hl_function" href="classthorin_1_1RuntimeCast.html#a9b3aab7e1699f26e91e8675de9c0b202">isa</a>&lt;<a class="code hl_class" href="classthorin_1_1Sigma.html">Sigma</a>&gt;()) {</div>
<div class="line">        <span class="comment">// sigma is of type &quot;const Sigma*&quot; and could be a mutable or an immutable</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// sigma of type &quot;const Sigma*&quot; and could be an immutable or a mutable</span></div>
<div class="line">    <span class="comment">// asserts, if def is not a Sigma</span></div>
<div class="line">    <span class="keyword">auto</span> sigma = def-&gt;<a class="code hl_function" href="classthorin_1_1Def.html#a5be55faa597959d9cd802aad81c6b57a">as_imm</a>&lt;<a class="code hl_class" href="classthorin_1_1Sigma.html">Sigma</a>&gt;();</div>
<div class="line">}</div>
<div class="ttc" id="aclassthorin_1_1Def_html_a5be55faa597959d9cd802aad81c6b57a"><div class="ttname"><a href="classthorin_1_1Def.html#a5be55faa597959d9cd802aad81c6b57a">thorin::Def::as_imm</a></div><div class="ttdeci">const T * as_imm() const</div><div class="ttdef"><b>Definition:</b> <a href="def_8h_source.html#l00406">def.h:406</a></div></div>
<div class="ttc" id="aclassthorin_1_1Ref_html"><div class="ttname"><a href="classthorin_1_1Ref.html">thorin::Ref</a></div><div class="ttdoc">Helper class to retrieve Infer::arg if present.</div><div class="ttdef"><b>Definition:</b> <a href="def_8h_source.html#l00076">def.h:76</a></div></div>
<div class="ttc" id="aclassthorin_1_1RuntimeCast_html_a9b3aab7e1699f26e91e8675de9c0b202"><div class="ttname"><a href="classthorin_1_1RuntimeCast.html#a9b3aab7e1699f26e91e8675de9c0b202">thorin::RuntimeCast::isa</a></div><div class="ttdeci">T * isa()</div><div class="ttdoc">dynamic_cast.</div><div class="ttdef"><b>Definition:</b> <a href="cast_8h_source.html#l00028">cast.h:28</a></div></div>
<div class="ttc" id="aclassthorin_1_1Sigma_html"><div class="ttname"><a href="classthorin_1_1Sigma.html">thorin::Sigma</a></div><div class="ttdoc">A dependent tuple type.</div><div class="ttdef"><b>Definition:</b> <a href="tuple_8h_source.html#l00009">tuple.h:9</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md18"></a>
Upcast for Immutables</h3>
<p ><a class="el" href="classthorin_1_1Def.html#a85d0612116079567f2ba644ac3b37ac8">Def::isa_imm</a>/<a class="el" href="classthorin_1_1Def.html#a5be55faa597959d9cd802aad81c6b57a">Def::as_imm</a> allows for an <em>upcast</em> and <b>only</b> matches <em>immutables</em>: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classthorin_1_1Ref.html">Ref</a> def) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> imm = def-&gt;<a class="code hl_function" href="classthorin_1_1Def.html#a85d0612116079567f2ba644ac3b37ac8">isa_imm</a>()) {</div>
<div class="line">        <span class="comment">// imm of type &quot;const Def*&quot; and is an immutable</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> sigma = def-&gt;<a class="code hl_function" href="classthorin_1_1Def.html#a85d0612116079567f2ba644ac3b37ac8">isa_imm</a>&lt;<a class="code hl_class" href="classthorin_1_1Sigma.html">Sigma</a>&gt;()) {</div>
<div class="line">        <span class="comment">// sigma is of type &quot;const Sigma*&quot; and is an immutable Sigma</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// sigma of type &quot;const Sigma*&quot; and *must* be an immutable Sigma - otherwise, asserts</span></div>
<div class="line">    <span class="keyword">auto</span> sigma = def-&gt;<a class="code hl_function" href="classthorin_1_1Def.html#a5be55faa597959d9cd802aad81c6b57a">as_imm</a>&lt;<a class="code hl_class" href="classthorin_1_1Sigma.html">Sigma</a>&gt;();</div>
<div class="line">}</div>
<div class="ttc" id="aclassthorin_1_1Def_html_a85d0612116079567f2ba644ac3b37ac8"><div class="ttname"><a href="classthorin_1_1Def.html#a85d0612116079567f2ba644ac3b37ac8">thorin::Def::isa_imm</a></div><div class="ttdeci">const T * isa_imm() const</div><div class="ttdef"><b>Definition:</b> <a href="def_8h_source.html#l00405">def.h:405</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md19"></a>
Upcast for Mutables</h3>
<p ><a class="el" href="classthorin_1_1Def.html#aabf1066a0dbcaa6ec6f08877b86767e4">Def::isa_mut</a>/<a class="el" href="classthorin_1_1Def.html#af11b2eb1d65239b9e9f5ca1920742ddb">Def::as_mut</a> allows for an <em>upcast</em> and <b>only</b> matches <em>mutables</em>. By doing so, it removes the <code>const</code> qualifier and gives you access to the <b>non</b>-<code>const</code> methods that only make sense for <em>mutables</em>: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classthorin_1_1Ref.html">Ref</a> def) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> mut = def-&gt;<a class="code hl_function" href="classthorin_1_1Def.html#aabf1066a0dbcaa6ec6f08877b86767e4">isa_mut</a>()) {</div>
<div class="line">        <span class="comment">// mut of type &quot;Def*&quot; - &quot;const&quot; has been removed!</span></div>
<div class="line">        <span class="comment">// This gives you access to the non-const methods:</span></div>
<div class="line">        <span class="keyword">auto</span> var = mut-&gt;var();</div>
<div class="line">        <span class="keyword">auto</span> stub = mut-&gt;stub(world, type, debug)</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> lam = def-&gt;<a class="code hl_function" href="classthorin_1_1Def.html#aabf1066a0dbcaa6ec6f08877b86767e4">isa_mut</a>&lt;<a class="code hl_class" href="classthorin_1_1Lam.html">Lam</a>&gt;()) {</div>
<div class="line">        <span class="comment">// lam of type &quot;Lam*&quot; - &quot;const&quot; has been removed!</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// lam of type &quot;Lam*&quot; and *must* be a mutable Lam.</span></div>
<div class="line">    <span class="comment">// Otherwise, an assert will fire.</span></div>
<div class="line">    <span class="keyword">auto</span> lam = def-&gt;<a class="code hl_function" href="classthorin_1_1RuntimeCast.html#a909777be7f178004b0cca5ec68356c4c">as</a>&lt;<a class="code hl_class" href="classthorin_1_1Lam.html">Lam</a>&gt;();</div>
<div class="line">}</div>
<div class="ttc" id="aclassthorin_1_1Def_html_aabf1066a0dbcaa6ec6f08877b86767e4"><div class="ttname"><a href="classthorin_1_1Def.html#aabf1066a0dbcaa6ec6f08877b86767e4">thorin::Def::isa_mut</a></div><div class="ttdeci">T * isa_mut() const</div><div class="ttdoc">If this is *mut*able, it will cast constness away and perform a dynamic_cast to T.</div><div class="ttdef"><b>Definition:</b> <a href="def_8h_source.html#l00411">def.h:411</a></div></div>
<div class="ttc" id="aclassthorin_1_1Lam_html"><div class="ttname"><a href="classthorin_1_1Lam.html">thorin::Lam</a></div><div class="ttdoc">A function.</div><div class="ttdef"><b>Definition:</b> <a href="lam_8h_source.html#l00094">lam.h:94</a></div></div>
<div class="ttc" id="aclassthorin_1_1RuntimeCast_html_a909777be7f178004b0cca5ec68356c4c"><div class="ttname"><a href="classthorin_1_1RuntimeCast.html#a909777be7f178004b0cca5ec68356c4c">thorin::RuntimeCast::as</a></div><div class="ttdeci">T * as()</div><div class="ttdoc">static_cast with debug check.</div><div class="ttdef"><b>Definition:</b> <a href="cast_8h_source.html#l00023">cast.h:23</a></div></div>
</div><!-- fragment --><p> Checking via <a class="el" href="classthorin_1_1RuntimeCast.html#a9b3aab7e1699f26e91e8675de9c0b202">Def::isa</a>/<a class="el" href="classthorin_1_1RuntimeCast.html#a909777be7f178004b0cca5ec68356c4c">Def::as</a> a <code>Def*</code> has the same effect as using <a class="el" href="classthorin_1_1Def.html#aabf1066a0dbcaa6ec6f08877b86767e4">Def::isa_mut</a>/<a class="el" href="classthorin_1_1Def.html#af11b2eb1d65239b9e9f5ca1920742ddb">Def::isa_mut</a> since the scrutinee must be already a <em>mutable</em> due to the lack of the <code>const</code> qualifier: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classthorin_1_1Def.html">Def</a>* def) { <span class="comment">// note the lack of &quot;const&quot; here</span></div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> sigma = def-&gt;<a class="code hl_function" href="classthorin_1_1RuntimeCast.html#a9b3aab7e1699f26e91e8675de9c0b202">isa</a>&lt;<a class="code hl_class" href="classthorin_1_1Sigma.html">Sigma</a>&gt;()) {</div>
<div class="line">        <span class="comment">// sigma is of type Sigma* and is a mutable</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> sigma = def-&gt;<a class="code hl_function" href="classthorin_1_1Def.html#aabf1066a0dbcaa6ec6f08877b86767e4">isa_mut</a>&lt;<a class="code hl_class" href="classthorin_1_1Sigma.html">Sigma</a>&gt;()) {</div>
<div class="line">        <span class="comment">// sigma is of type Sigma* and is a mutable</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// sigma of type &quot;Sigma*&quot; and is a mutable - otherwise, asserts</span></div>
<div class="line">    <span class="keyword">auto</span> sigma = def-&gt;<a class="code hl_function" href="classthorin_1_1RuntimeCast.html#a909777be7f178004b0cca5ec68356c4c">as</a>&lt;<a class="code hl_class" href="classthorin_1_1Sigma.html">Sigma</a>&gt;();</div>
<div class="line">}</div>
<div class="ttc" id="aclassthorin_1_1Def_html"><div class="ttname"><a href="classthorin_1_1Def.html">thorin::Def</a></div><div class="ttdoc">Base class for all Defs.</div><div class="ttdef"><b>Definition:</b> <a href="def_8h_source.html#l00203">def.h:203</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="cast_lit"></a>
Matching Literals</h3>
<p >Often, you want to match a <a class="el" href="classthorin_1_1Lit.html">Lit</a>eral and grab its content. You can use <a class="el" href="classthorin_1_1Lit.html#a04e7f971dc843037de73711a723ac92d">Lit::isa</a>/<a class="el" href="classthorin_1_1Lit.html#a12cee0e56262c6b7414ef0846046011a">Lit::as</a> for this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classthorin_1_1Ref.html">Ref</a> def) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> lit = Lit::isa(def)) {</div>
<div class="line">        <span class="comment">// lit is of type &quot;std::optional&lt;u64&gt;&quot;</span></div>
<div class="line">        <span class="comment">// It&#39;s your responsibility that the grabbed value makes sense as u64.</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> lit = Lit::isa&lt;f32&gt;(def)) {</div>
<div class="line">        <span class="comment">// lit is of type &quot;std::optional&lt;f32&gt;&quot;</span></div>
<div class="line">        <span class="comment">// It&#39;s your responsibility that the grabbed value makes sense as f32.</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// asserts if def is not a Lit.</span></div>
<div class="line">    <span class="keyword">auto</span> lu64 = Lit::as(def);</div>
<div class="line">    <span class="keyword">auto</span> lf32 = Lit::as&lt;f32&gt;(def);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md20"></a>
Summary</h3>
<p >The following table summarizes all important casts:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><code>dynamic_cast</code> <br  />
 <code>static_cast</code>   </th><th class="markdownTableHeadNone">Returns   </th><th class="markdownTableHeadNone">If <code>def</code> is a ...    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>def-&gt;isa&lt;Lam&gt;()</code> <br  />
 <code>def-&gt;as&lt;Lam&gt;()</code>   </td><td class="markdownTableBodyNone"><code>const Lam*</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Lam.html">Lam</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>def-&gt;isa_imm&lt;Lam&gt;()</code> <br  />
 <code>def-&gt;as_imm&lt;Lam&gt;()</code>   </td><td class="markdownTableBodyNone"><code>const Lam*</code>   </td><td class="markdownTableBodyNone"><b>immutable</b> <a class="el" href="classthorin_1_1Lam.html">Lam</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>def-&gt;isa_mut&lt;Lam&gt;()</code> <br  />
 <code>def-&gt;as_mut&lt;Lam&gt;()</code>   </td><td class="markdownTableBodyNone"><code>Lam*</code>   </td><td class="markdownTableBodyNone"><b>mutable</b> <a class="el" href="classthorin_1_1Lam.html">Lam</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Lit::isa(def)</code> <br  />
 <code>Lit::as(def)</code>   </td><td class="markdownTableBodyNone"><a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a><code>&lt;</code><a class="el" href="namespacethorin.html#a529e2848fe27ea9f7ccf59bec4fd1e91">nat_t</a><code>&gt;</code> <br  />
 <a class="el" href="namespacethorin.html#a529e2848fe27ea9f7ccf59bec4fd1e91">nat_t</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Lit.html">Lit</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Lit::isa&lt;f32&gt;(def)</code> <br  />
 <code>Lit::as&lt;f32&gt;(def)</code>   </td><td class="markdownTableBodyNone"><a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a><code>&lt;</code><a class="el" href="namespacethorin.html#ae683288c4230cd715c4179947ecd4772">f32</a><code>&gt;</code> <br  />
 <a class="el" href="namespacethorin.html#ae683288c4230cd715c4179947ecd4772">f32</a>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Lit.html">Lit</a>   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md21"></a>
Further Casts</h3>
<p >There are also some additional checks available that usually come as <code>static</code> methods and either return a pointer or <code>Ref</code> to the checked entity or <code>nullptr</code>. Here are some examples: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classthorin_1_1Ref.html">Ref</a> def) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> size = Idx::size(def)) {</div>
<div class="line">        <span class="comment">// def = .Idx size</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> lam = Lam::isa_mut_cn(def)) {</div>
<div class="line">        <span class="comment">// def isa mutable Lam of type .Cn T</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> pi = Pi::isa_basicblock(def)) {</div>
<div class="line">        <span class="comment">// def is a Pi whose co-domain is bottom and which is not returning</span></div>
<div class="line">    }</div>
</div><!-- fragment --><h2><a class="anchor" id="cast_axiom"></a>
Matching Axioms</h2>
<p >You can match <a class="el" href="classthorin_1_1Axiom.html">Axiom</a>s via</p><ul>
<li><a class="el" href="namespacethorin.html#a38ddc530ce32edb30248a9bb99c6c90d">thorin::match</a> which is again similar to a <code>dynamic_cast</code> with a runtime check and returns <a class="el" href="classthorin_1_1Match.html#a1c485e4f1115270df5028011fc1fca30">a wrapped</a> <code>nullptr</code> (see below), if the cast is not possible, or</li>
<li><a class="el" href="namespacethorin.html#a73e99aec74e2e132591d174b75bb920b">thorin::force</a> which is again more like a <code>static_cast</code> and <code>assert</code>s via its <a class="el" href="namespacethorin.html#a38ddc530ce32edb30248a9bb99c6c90d">thorin::match</a> sibling in the <code>Debug</code> build that the cast is correct.</li>
</ul>
<p >This will yield a <a class="el" href="classthorin_1_1Match.html">Match</a><code>&lt;Id, D&gt;</code> which just wraps a <code>const D*</code>. <code>Id</code> is the <code>enum</code> of the corresponding <code>tag</code> of the <a class="el" href="classthorin_1_1Axiom.html#anatomy">matched Axiom</a>. Usually, <code>D</code> will be an <a class="el" href="classthorin_1_1App.html">App</a> because most <a class="el" href="classthorin_1_1Axiom.html">Axiom</a>s inhabit a <a class="el" href="classthorin_1_1Pi.html">function type</a>. Otherwise, it may wrap a <a class="el" href="classthorin_1_1Def.html">Def</a> or other subclasses of it. For instance, <a class="el" href="namespacethorin.html#a38ddc530ce32edb30248a9bb99c6c90d">match</a>ing <code>%mem.M</code> yields <a class="el" href="classthorin_1_1Match.html">Match</a><code>&lt;</code><a class="el" href="namespacethorin_1_1mem.html#abab7091b7bb05e14f8f9e7081981fb7c">mem::M</a>, <a class="el" href="classthorin_1_1Def.html">Def</a><code>&gt;</code>.</p>
<p >By default, Thorin assumes that the magic of an <a class="el" href="classthorin_1_1Axiom.html">Axiom</a> happens when applying the final argument to a curried <a class="el" href="classthorin_1_1Axiom.html">Axiom</a>. For example, <a class="el" href="namespacethorin.html#a38ddc530ce32edb30248a9bb99c6c90d">match</a>ing a <code>%mem.load</code> will only trigger for the final <a class="el" href="classthorin_1_1App.html">App</a> of the curried call </p><div class="fragment"><div class="line">%mem.load (T, as) (mem, ptr)</div>
</div><!-- fragment --><p> while </p><div class="fragment"><div class="line">%mem.load (T, as)</div>
</div><!-- fragment --><p> will <b>not</b> match. The wrapped <a class="el" href="classthorin_1_1App.html">App</a> inside the <a class="el" href="classthorin_1_1Match.html">Match</a> refers to the last <a class="el" href="classthorin_1_1App.html">App</a> of the curried call. So in this example</p><ul>
<li><a class="el" href="classthorin_1_1App.html#a87f636308044d3ec0ee571f9d5658bc7">thorin::App::arg()</a> is <code>(mem, ptr)</code> and</li>
<li><p class="startli"><a class="el" href="classthorin_1_1App.html#a50ea8f8c25098398c902dfcc011af9ff">thorin::App::callee()</a> is <code>%mem.load (T, as)</code>.</p>
<p class="startli">Use <a class="el" href="classthorin_1_1App.html#a53a3f213bce08f36aa352ceebe3e2518" title="Returns App::callee again as App.">thorin::App::decurry()</a> to directly get the <a class="el" href="classthorin_1_1App.html#a50ea8f8c25098398c902dfcc011af9ff">thorin::App::callee()</a> as <a class="el" href="classthorin_1_1App.html">thorin::App</a>.</p>
</li>
</ul>
<p >If you want to design an <a class="el" href="classthorin_1_1Axiom.html">Axiom</a> that returns a function, you can <a class="el" href="classthorin_1_1Axiom.html#normalization">fine-adjust the trigger point</a> of a <a class="el" href="namespacethorin.html#a38ddc530ce32edb30248a9bb99c6c90d">thorin::match</a> / <a class="el" href="namespacethorin.html#a73e99aec74e2e132591d174b75bb920b">thorin::force</a>.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
w/o Subtags</h3>
<p >In order to match an <a class="el" href="classthorin_1_1Axiom.html">Axiom</a> <b>without</b> any subtags like <code>%mem.load</code>, do this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classthorin_1_1Ref.html">Ref</a> def) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> load = match&lt;mem::load&gt;(def)) {</div>
<div class="line">        <span class="keyword">auto</span> [mem, ptr]            = load-&gt;args&lt;2&gt;();</div>
<div class="line">        <span class="keyword">auto</span> [pointee, addr_space] = load-&gt;decurry()-&gt;args&lt;2&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// def must match as a mem::load - otherwise, asserts</span></div>
<div class="line">    <span class="keyword">auto</span> load = force&lt;mem::load&gt;(def);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md23"></a>
w/ Subtags</h3>
<p >In order to match an <a class="el" href="classthorin_1_1Axiom.html">Axiom</a> <b>with</b> subtags like <code>%core.wrap</code>, do this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<a class="code hl_class" href="classthorin_1_1Ref.html">Ref</a> def) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> wrap = match&lt;core::wrap&gt;(def)) {</div>
<div class="line">        <span class="keyword">auto</span> [a, b] = wrap-&gt;args&lt;2&gt;();</div>
<div class="line">        <span class="keyword">auto</span> mode   = wrap-&gt;decurry()-&gt;arg();</div>
<div class="line">        <span class="keywordflow">switch</span> (wrap.id()) {</div>
<div class="line">            <span class="keywordflow">case</span> core::wrap::add: <span class="comment">// ...</span></div>
<div class="line">            <span class="keywordflow">case</span> core::wrap::sub: <span class="comment">// ...</span></div>
<div class="line">            <span class="keywordflow">case</span> core::wrap::mul: <span class="comment">// ...</span></div>
<div class="line">            <span class="keywordflow">case</span> core::wrap::shl: <span class="comment">// ...</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> add = <a class="code hl_function" href="namespacethorin.html#a38ddc530ce32edb30248a9bb99c6c90d">match</a>(core::wrap::add, def)) {</div>
<div class="line">        <span class="keyword">auto</span> [<a class="code hl_enumvalue" href="namespacethorin_1_1core.html#ae493f33140e983cf79dc6b66a1637628a85b63feaff2f38f8b5976454a8355a7d">a</a>, b] = <a class="code hl_enumeration" href="namespacethorin_1_1autodiff.html#a401c1924abe6294a7a98d2318c21289c">add</a>-&gt;args&lt;2&gt;();</div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_enumeration" href="namespacethorin_1_1core.html#a9560903c6caf317c161b54117e2e2679">mode</a>   = <a class="code hl_enumeration" href="namespacethorin_1_1autodiff.html#a401c1924abe6294a7a98d2318c21289c">add</a>-&gt;decurry()-&gt;arg();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// def must match as a core::wrap - otherwise, asserts</span></div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_enumeration" href="namespacethorin_1_1core.html#ab1f42e21a4de8bd328e18b8006b9f74f">wrap</a> = force&lt;core::wrap&gt;(def);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// def must match as a core::wrap::add - otherwise, asserts</span></div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_enumeration" href="namespacethorin_1_1autodiff.html#a401c1924abe6294a7a98d2318c21289c">add</a> = <a class="code hl_function" href="namespacethorin.html#a73e99aec74e2e132591d174b75bb920b">force</a>(core::wrap::add, def);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacethorin_1_1autodiff_html_a401c1924abe6294a7a98d2318c21289c"><div class="ttname"><a href="namespacethorin_1_1autodiff.html#a401c1924abe6294a7a98d2318c21289c">thorin::autodiff::add</a></div><div class="ttdeci">add</div><div class="ttdef"><b>Definition:</b> <a href="autodiff_2autogen_8h_source.html#l00063">autogen.h:63</a></div></div>
<div class="ttc" id="anamespacethorin_1_1core_html_a9560903c6caf317c161b54117e2e2679"><div class="ttname"><a href="namespacethorin_1_1core.html#a9560903c6caf317c161b54117e2e2679">thorin::core::mode</a></div><div class="ttdeci">mode</div><div class="ttdef"><b>Definition:</b> <a href="core_2autogen_8h_source.html#l00174">autogen.h:174</a></div></div>
<div class="ttc" id="anamespacethorin_1_1core_html_ab1f42e21a4de8bd328e18b8006b9f74f"><div class="ttname"><a href="namespacethorin_1_1core.html#ab1f42e21a4de8bd328e18b8006b9f74f">thorin::core::wrap</a></div><div class="ttdeci">wrap</div><div class="ttdef"><b>Definition:</b> <a href="core_2autogen_8h_source.html#l00272">autogen.h:272</a></div></div>
<div class="ttc" id="anamespacethorin_1_1core_html_ae493f33140e983cf79dc6b66a1637628a85b63feaff2f38f8b5976454a8355a7d"><div class="ttname"><a href="namespacethorin_1_1core.html#ae493f33140e983cf79dc6b66a1637628a85b63feaff2f38f8b5976454a8355a7d">thorin::core::a</a></div><div class="ttdeci">@ a</div><div class="ttdef"><b>Definition:</b> <a href="core_2autogen_8h_source.html#l00259">autogen.h:259</a></div></div>
<div class="ttc" id="anamespacethorin_html_a38ddc530ce32edb30248a9bb99c6c90d"><div class="ttname"><a href="namespacethorin.html#a38ddc530ce32edb30248a9bb99c6c90d">thorin::match</a></div><div class="ttdeci">auto match(Ref def)</div><div class="ttdef"><b>Definition:</b> <a href="axiom_8h_source.html#l00108">axiom.h:108</a></div></div>
<div class="ttc" id="anamespacethorin_html_a73e99aec74e2e132591d174b75bb920b"><div class="ttname"><a href="namespacethorin.html#a73e99aec74e2e132591d174b75bb920b">thorin::force</a></div><div class="ttdeci">auto force(Ref def)</div><div class="ttdef"><b>Definition:</b> <a href="axiom_8h_source.html#l00130">axiom.h:130</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Summary</h3>
<p >The following table summarizes all important casts:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><code>dynamic_cast</code> <br  />
 <code>static_cast</code>   </th><th class="markdownTableHeadNone">Returns   </th><th class="markdownTableHeadNone">If <code>def</code> is a ...    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>match&lt;mem::load&gt;(def)</code> <br  />
 <code>force&lt;mem::load&gt;(def)</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Match.html">Match</a><code>&lt;</code><a class="el" href="namespacethorin_1_1mem.html#adb2bf49c45c2574f69f55e237f3f2e8f">mem::load</a>, <a class="el" href="classthorin_1_1App.html">App</a><code>&gt;</code>   </td><td class="markdownTableBodyNone"><code>%mem.load (T, as) (mem, ptr)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>match&lt;core::wrap&gt;(def)</code> <br  />
 <code>force&lt;core::wrap&gt;(def)</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Match.html">Match</a><code>&lt;</code><a class="el" href="namespacethorin_1_1mem.html#adb2bf49c45c2574f69f55e237f3f2e8f">core::wrap</a>, <a class="el" href="classthorin_1_1App.html">App</a><code>&gt;</code>   </td><td class="markdownTableBodyNone"><code>%core.wrap.??? s m (a, b)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>match(core::wrap::add, def)</code> <br  />
 <code>force(core::wrap::add, def)</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Match.html">Match</a><code>&lt;</code><a class="el" href="namespacethorin_1_1mem.html#adb2bf49c45c2574f69f55e237f3f2e8f">core::wrap</a>, <a class="el" href="classthorin_1_1App.html">App</a><code>&gt;</code>   </td><td class="markdownTableBodyNone"><code>%core.wrap.add s m (a, b)</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md25"></a>
Working with Indices</h1>
<p >There are essentially <b>three</b> ways of retrieving the number of elements of something in Thorin.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Arity</h2>
<p >This is the number of elements of to <a class="el" href="classthorin_1_1Extract.html">extract</a>/<a class="el" href="classthorin_1_1Insert.html">insert</a> a single element. Note that the number of elements may be unknown at compile time such as in <code>‹n; 0›</code>.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Proj</h2>
<p ><a class="el" href="classthorin_1_1Def.html#ade4d2dbcacdc78e6662c7ddf431f57e2" title="Yields Def::as_lit_arity(), if it is in fact a Lit, or 1 otherwise.">thorin::Def::num_projs</a> is the same as <a class="el" href="classthorin_1_1Def.html#a141dd0a4acc004e3b6d70f64c6ca41b6">thorin::Def::arity</a>, if the arity is a <a class="el" href="classthorin_1_1Lit.html">thorin::Lit</a>. Otherwise, it is simply <code>1</code>. This concept only exists in the C++-API to give the programmer the illusion to work with n-ary functions, e.g.: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> dom : pi-&gt;doms()) { <span class="comment">/*...*/</span> }</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> var : lam-&gt;vars()) { <span class="comment">/*...*/</span> }</div>
</div><!-- fragment --><p> But in reality, all functions have exactly one domain and one codomain.</p>
<p >See also:</p><ul>
<li><a class="el" href="classthorin_1_1Def.html#proj">Def::proj</a></li>
<li><a class="el" href="classthorin_1_1Def.html#var">Def::var</a></li>
<li><a class="el" href="classthorin_1_1Pi.html#pi_dom">Pi::dom</a></li>
<li><a class="el" href="classthorin_1_1Pi.html#pi_codom">Pi::codom</a></li>
<li><a class="el" href="classthorin_1_1Lam.html#lam_dom">Lam::dom</a></li>
<li><a class="el" href="classthorin_1_1Lam.html#lam_codom">Lam::codom</a></li>
<li><a class="el" href="classthorin_1_1App.html#app_arg">App::arg</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
Shape</h2>
<p >TODO</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Summary</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Expression   </th><th class="markdownTableHeadNone">Class   </th><th class="markdownTableHeadNone"><a class="el" href="classthorin_1_1Def.html#a141dd0a4acc004e3b6d70f64c6ca41b6">artiy</a>   </th><th class="markdownTableHeadNone"><a class="el" href="classthorin_1_1Def.html#a3435dfa9281402d7c74e7a163ec0a6d8">isa_lit_artiy</a>   </th><th class="markdownTableHeadNone"><a class="el" href="classthorin_1_1Def.html#a16d05019a1084e09ba37ca6eb14fc36d">as_lit_artiy</a>   </th><th class="markdownTableHeadNone"><a class="el" href="classthorin_1_1Def.html#ade4d2dbcacdc78e6662c7ddf431f57e2">num_projs</a>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>(0, 1, 2)</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Tuple.html">Tuple</a>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>‹3; 0›</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Pack.html">Pack</a>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>‹n; 0›</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Pack.html">Pack</a>   </td><td class="markdownTableBodyNone"><code>n</code>   </td><td class="markdownTableBodyNone"><code>std::nullopt</code>   </td><td class="markdownTableBodyNone">asserts   </td><td class="markdownTableBodyNone"><code>1</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>[.Nat, .Bool, .Nat]</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Sigma.html">Sigma</a>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>«3; .Nat»</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Arr.html">Arr</a>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>   </td><td class="markdownTableBodyNone"><code>3</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>«n; .Nat»</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Arr.html">Arr</a>   </td><td class="markdownTableBodyNone"><code>n</code>   </td><td class="markdownTableBodyNone"><code>std::nullopt</code>   </td><td class="markdownTableBodyNone">asserts   </td><td class="markdownTableBodyNone"><code>1</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>x: [.Nat, .Bool]</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Var.html">Var</a>   </td><td class="markdownTableBodyNone"><code>2</code>   </td><td class="markdownTableBodyNone"><code>2</code>   </td><td class="markdownTableBodyNone"><code>2</code>   </td><td class="markdownTableBodyNone"><code>2</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>x: «n; .Nat»</code>   </td><td class="markdownTableBodyNone"><a class="el" href="classthorin_1_1Var.html">Var</a>   </td><td class="markdownTableBodyNone"><code>n</code>   </td><td class="markdownTableBodyNone"><code>std::nullopt</code>   </td><td class="markdownTableBodyNone">asserts   </td><td class="markdownTableBodyNone"><code>1</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md30"></a>
Iterating over the Program</h1>
<p >There are several ways of doing this. It depends on what exactly you want to achieve and how much structure you need during the traversal. The simplest way is to kick off with <a class="el" href="classthorin_1_1World.html#a5b40a0d582ba6e1b28bc50dc0ceb0840">World::externals</a> and recursively run over <a class="el" href="classthorin_1_1Def.html#a543cbdcb17d574373aa65244dcead8f8">Def::extended_ops</a> like this: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacethorin.html#a7fddaff34d4e4927bc748c28b49eef46">DefSet</a> done;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [_, mut] : world.externals())</div>
<div class="line">    visit(done, mut);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> visit(<a class="code hl_typedef" href="namespacethorin.html#a7fddaff34d4e4927bc748c28b49eef46">DefSet</a>&amp; done, <span class="keyword">const</span> <a class="code hl_class" href="classthorin_1_1Def.html">Def</a>* def) {</div>
<div class="line">    <span class="keywordflow">if</span> (!done.emplace(def).second) <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">    do_sth(def);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> op : def-&gt;<a class="code hl_function" href="classthorin_1_1Def.html#a543cbdcb17d574373aa65244dcead8f8">extended_ops</a>())</div>
<div class="line">        visit(done, op);</div>
<div class="line">}</div>
<div class="ttc" id="aclassthorin_1_1Def_html_a543cbdcb17d574373aa65244dcead8f8"><div class="ttname"><a href="classthorin_1_1Def.html#a543cbdcb17d574373aa65244dcead8f8">thorin::Def::extended_ops</a></div><div class="ttdeci">Defs extended_ops() const</div><div class="ttdef"><b>Definition:</b> <a href="def_8cpp_source.html#l00254">def.cpp:254</a></div></div>
<div class="ttc" id="anamespacethorin_html_a7fddaff34d4e4927bc748c28b49eef46"><div class="ttname"><a href="namespacethorin.html#a7fddaff34d4e4927bc748c28b49eef46">thorin::DefSet</a></div><div class="ttdeci">GIDSet&lt; const Def * &gt; DefSet</div><div class="ttdef"><b>Definition:</b> <a href="def_8h_source.html#l00051">def.h:51</a></div></div>
</div><!-- fragment --><p> However, you will most likely want to use the <a class="el" href="passes.html#md_docs_passes">pass</a> or the phase infrastructure. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
