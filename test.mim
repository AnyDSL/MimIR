import core;
import mem;

// axm %test.inf: %test.Idx %test.inf;
// axm %test.Idx: %test.Idx -> *;
// let %test.Nat = %test.Idx %test.inf;

// axm %test.add: {n m: %test.Nat} -> [a: %test.Idx n, b: %test.Idx m] -> %test.Idx (%test.add (n, m));

// lam extern add {n m: %test.Nat} [a: %test.Idx n, b: %test.Idx m]: %test.Idx (%test.add (n, m)) = %test.add (a, b);
//
let add = %core.nat.add;
let sub = %core.nat.sub;

// lam extern test1 [v: Nat]: Nat = add(1, add (add (v, 1), 1));
// lam extern test2 [v: Nat]: Nat = add (1, 1);

lam idx_add_nat {n: Nat} [a: Idx n, m: Nat] : Idx (add (n, m))
    = %core.bitcast (Idx (add (n, m))) (add (a_, m))
        where
            let a_ = %core.bitcast Nat a;
        end;

axm %test.Void: *;

lam %test.map
    {n: Nat}
    {T U: □}
    [f: T -> U]
    [vals: «n; T»]
  : «n; U»
  = ‹i: n; f (vals#i)›;

lam %test.fold.l
    {n: Nat}
    {A V: □}
    [f: [A, V] → A]
    [acc: A, vals: «n; V»]
  : A
  = (%test.fold.l f (f (acc, vals#0), rest), acc)#(%core.ncmp.e (n, 0))
    where
        let rest = ‹i: sub (n, 1); vals#(idx_add_nat (i, 1))›;
    end;

lam %test.liftsq {A T: *} [f: [A, T] → A]: [[*, A], [*, T]] → [*, A]
    = (λ [[*, acc: A], [*, v: T]]: [*, A] = (%test.Void, f (acc, v)));

lam %test.wrapsq {T: *} {n: Nat} [vals: «n; T»]: «n; [*, T]» = ‹i: n; (%test.Void, vals#i)›;

fun extern sum1 {n: Nat} [vals: «n; Nat»]: Nat
  = (%test.fold.l f_ ((%test.Void, 0), %test.wrapsq vals))#1
    where
        lam f_ [[*, acc: Nat], [*, v: Nat]]: [*, Nat] = (%test.Void, %core.nat.add (acc, v));
    end;

// lam extern blub (): «sum1 (1, 1, 0); Nat» = ‹2; 0›;

// lam extern %test.memmap
//     {n: Nat}
//     {T U: *}
//     [f: [%mem.M, T] -> [%mem.M, U]]
//     [mem: %mem.M, «n; T»]
//   : [%mem.M, «n; U»]
//   =
// lam extern %test.memmap
//     {n: Nat} {T U: *} [f: [%mem.M, T] -> [%mem.M, U]] [mem: %mem.M, «n; T»]: [%mem.M, «n; U»]
//   = %test.fold load (mem, ())
//     where
//         lam load [%mem.M, ]

// axm %test.kfold(l): {A E: □} → {n: Nat} → [f: [A, E] → A] → [A, «n; E»] → A, normalize_fold;

// lam %test.fold.l {A E: *} {n: Nat} [f: [A, E] → A] [acc: A, data: «n; E»]: A
//     = (%test.kfold.l (%test.liftsq f) ((%test.Void, acc), %test.wrapsq data))#1;

// lam extern sum {n: Nat} [vals: «n; Nat»]
//     = %test.fold.l (λ [acc v: Nat] = %core.nat.add acc v) (0, vals);

// lam extern test () = (%test.Void, 3);

// lam extern foo {T: □} [a: T]: T = a;

// lam extern blub {T: ★} [a: T]: T = (foo (T, a))#1;

// lam extern blub2 [a: Nat]: Nat = (foo (Bool, a))#1;



// lam %core.idx.add {n m: Nat} [a: Idx n, b: Idx m] : Idx (%core.nat.add (n, m))
//     = %core.bitcast (Idx %core.nat.add (n, m)) (%core.nat.add (a_, b_))
//         where
//             let a_ = %core.bitcast Nat a;
//             let b_ = %core.bitcast Nat b;
//         end;

// lam %core.idx.addn {n: Nat} [a: Idx n, m: Nat] : Idx (%core.nat.add (n, m))
//     = %core.bitcast (Idx %core.nat.add (n, m)) (%core.nat.add (a_, m))
//         where
//             let a_ = %core.bitcast Nat a;
//         end;

// lam load_all
//     {n: Nat}
//     {Ts: <<n; *>>}
//     [mem: %mem.M, ptrs: <<i: n; %mem.Ptr0 Ts#i>>]
//         : [%mem.M, <<i: n; Ts#i>>]
//         =
//             where
//                 let n_ = %core.nat.sub (n, 1);
//                 let (f, fT) = (ptrs#0, Ts#0);
//                 let r = (<i: n_; ptrs#(%core.idx.addn (i, 1))>);
//                 let rTs = (<i: n_; Ts#(%core.idx.addn (i, 1))>);
//                 let (mem_, vals) = load_all (mem, ptrs)
//             end;

// axm %test.blub: ex_type;
