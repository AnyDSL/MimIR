/// # The spirv Plugin {#spirv}
///
/// @see mim::plug::spirv
///
/// [TOC]
///
/// A plugin providing a spir-v backend for MimIR.
///
import core;
import math;
import mem;
import vec;
import refly;

/// ## Execution Models
///
axm %spirv.Model: ★;
axm %spirv.model(fragment, vertex, compute): %spirv.Model;

axm %spirv.Mode: ★;
axm %spirv.mode(
    invocations,
    spacing_equal,
    spacing_fractional_even,
    spacing_fractional_odd,
    vertex_order_cw,
    vertex_order_ccw,
    pixel_center_integer,
    origin_upper_left,
    origin_lower_left,
    early_fragment_tests,
    // TODO: add more modes
): %spirv.Mode;

axm %spirv.entry: %spirv.Model → {n: Nat} → «n; %spirv.Mode» → ★;

/// ## Decorations
///
axm %spirv.Decoration: ★;

axm %spirv.decorc(block): %spirv.Decoration;
axm %spirv.decor(mk_builtin): %spirv.Model → Nat → %spirv.Decoration;
axm %spirv.decor(location): Nat → %spirv.Decoration;

/// ## Storage Classes
///
axm %spirv.storage(Class): ★;
axm %spirv.storage(INPUT):   %spirv.storage.Class;
axm %spirv.storage(OUTPUT):  %spirv.storage.Class;
axm %spirv.storage(UNIFORM): %spirv.storage.Class;

/// ## Globals
///
axm %spirv.Global: %spirv.storage.Class → {n: Nat} → «n; %spirv.Decoration» → ★ → ★;

let %spirv.Input = %spirv.Global %spirv.storage.INPUT;
let %spirv.Output = %spirv.Global %spirv.storage.OUTPUT;
let %spirv.Uniform = %spirv.Global %spirv.storage.UNIFORM;

axm %spirv.loadable: %spirv.storage.Class → Bool, normalize_loadable;
axm %spirv.load: {class: %spirv.storage.Class}
    → {n: Nat, decs: «n; %spirv.Decoration»}
    → {T: ★}
    → [%mem.M 0, %spirv.Global
        // (%refly.check (%spirv.loadable class, class, "storage class not loadable"))
        class
        decs T]
    → [%mem.M 0, T];

axm %spirv.storable: %spirv.storage.Class → Bool, normalize_storable;
axm %spirv.store: {class: %spirv.storage.Class}
    → {n: Nat, decs: «n; %spirv.Decoration»}
    → {T: ★}
    → [%mem.M 0, %spirv.Global
        // (%refly.check (%spirv.storable class, class, "storage class not storable"))
        class
        decs T, T]
    → [%mem.M 0];

/// ## Builtins
///
let %spirv.builtin.frag_coord
    = %spirv.Input (%spirv.decor.mk_builtin %spirv.model.fragment 15) «2; %math.F32»;

let %spirv.builtin.vertex_index
    = %spirv.Input  (%spirv.decor.mk_builtin %spirv.model.vertex 42) (Idx 3);
let %spirv.builtin.instance_index
    = %spirv.Input  (%spirv.decor.mk_builtin %spirv.model.vertex 43) Nat;
let %spirv.builtin.vertex_id
    = %spirv.Input  (%spirv.decor.mk_builtin %spirv.model.vertex  5) Nat;
let %spirv.builtin.instance_id
    = %spirv.Input  (%spirv.decor.mk_builtin %spirv.model.vertex  6) Nat;
let %spirv.builtin.position
    = %spirv.Output (%spirv.decor.mk_builtin %spirv.model.vertex  0) «4; %math.F32»;
