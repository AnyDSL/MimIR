/// # The spirv Plugin {#spirv}
///
/// @see mim::plug::spirv
///
/// [TOC]
///
/// A plugin providing a spir-v backend for MimIR.
///
import core;
import math;
import mem;
import vec;
import refly;

/// ## execution models
axm %spirv.Model: ★;
axm %spirv.model(fragment, vertex, compute): %spirv.Model;

/// ## decorations
axm %spirv.Decoration: ★;

axm %spirv.decorc(block): %spirv.Decoration;
axm %spirv.decor(builtin): {n: Nat} → «n; I8» → %spirv.Decoration;
axm %spirv.decor(location): Nat → %spirv.Decoration;

/// ## globals
axm %spirv.Input:   {n: Nat} → «n; %spirv.Decoration» → ★ → ★;
axm %spirv.Output:  {n: Nat} → «n; %spirv.Decoration» → ★ → ★;
axm %spirv.Uniform: {n: Nat} → «n; %spirv.Decoration» → ★ → ★;

axm %spirv.input(load):   {n: Nat, decs: «n; %spirv.Decoration»}
  → {T: ★} → [%mem.M 0, %spirv.Input   decs T]    → [%mem.M 0, T];
axm %spirv.output(store): {n: Nat, decs: «n; %spirv.Decoration»}
  → {T: ★} → [%mem.M 0, %spirv.Output  decs T, T] → [%mem.M 0];
axm %spirv.uniform(load): {n: Nat, decs: «n; %spirv.Decoration»}
  → {T: ★} → [%mem.M 0, %spirv.Uniform decs T]    → [%mem.M 0, T];

let fragment_builtins = [
    frag_coord:     %spirv.Input  (%spirv.decor.builtin "FragCoord"    ) «2; %math.F32»,
];

let vertex_builtins = [
    vertex_index:   %spirv.Input  (%spirv.decor.builtin "VertexIndex"  ) (Idx 3),
    instance_index: %spirv.Input  (%spirv.decor.builtin "InstanceIndex") Nat,
    vertex_id:      %spirv.Input  (%spirv.decor.builtin "VertexId"     ) Nat,
    instance_id:    %spirv.Input  (%spirv.decor.builtin "InstanceId"   ) Nat,

    position:       %spirv.Output (%spirv.decor.builtin "Position"     ) Nat,
];

let compute_builtins = [];

axm %spirv.builtins: %spirv.Model → ★;
// lam %spirv.builtins (model: %spirv.Model): ★
//   = match model with
//         | %spirv.model.fragment => fragment_builtins
//         | %spirv.model.vertex   => vertex_builtins
//         | %spirv.model.compute  => compute_builtins;

/// ## Entry Points
///
/// Spir-V modules can have multiple entry points. Every external function of type
/// `Fn () -> %spirv.Entry` gets converted to an entry point in the produced module.
axm %spirv.Entry: ★;

/// Creates an entry point from an execution model and a function
axm %spirv.entry:
    {model: %spirv.Model}
  → {ni no nu: Nat}
  → {Ti: «ni; ★»}
  → {To: «no; ★»}
  → {Tu: «nu; ★»}
  → {idcs: «ni; %spirv.Decoration»}
  → {odcs: «no; %spirv.Decoration»}
  → {udcs: «nu; %spirv.Decoration»}
  → [Fn [%mem.M 0]
      → [%spirv.builtins model]
      → «i: ni; %spirv.Input   idcs#i Ti#i»
      → «i: no; %spirv.Output  odcs#i To#i»
      → «i: nu; %spirv.Uniform udcs#i Tu#i»
      → [%mem.M 0]]
  → %spirv.Entry;
