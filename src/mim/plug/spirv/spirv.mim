/// # The spirv Plugin {#spirv}
///
/// @see mim::plug::spirv
///
/// [TOC]
///
/// A plugin providing a spir-v backend for MimIR.
///
import core;
import math;
import mem;
import vec;
import refly;

/// ## Execution Models
///
axm %spirv.Model: □;
axm %spirv.model(Fragment, Vertex, Compute): %spirv.Model;

/// ## Decorations
///
axm %spirv.Decoration: ★;

axm %spirv.decorc(block): %spirv.Decoration;
axm %spirv.decor(builtin): %spirv.Model → {n: Nat} → «n; I8» → %spirv.Decoration;
axm %spirv.decor(location): Nat → %spirv.Decoration;

/// ## Storage Classes
///
axm %spirv.storage(Class): ★;
axm %spirv.storage(INPUT):   %spirv.storage.Class;
axm %spirv.storage(OUTPUT):  %spirv.storage.Class;
axm %spirv.storage(UNIFORM): %spirv.storage.Class;

/// ## Globals
///
axm %spirv.Global: %spirv.storage.Class → {n: Nat} → «n; %spirv.Decoration» → ★ → ★;

let %spirv.Input = %spirv.Global %spirv.storage.INPUT;
let %spirv.Output = %spirv.Global %spirv.storage.OUTPUT;
let %spirv.Uniform = %spirv.Global %spirv.storage.UNIFORM;

axm %spirv.loadable: %spirv.storage.Class → Bool, normalize_loadable;
axm %spirv.load: {class: %spirv.storage.Class}
    → {n: Nat, decs: «n; %spirv.Decoration»}
    → {T: ★}
    → [%mem.M 0, %spirv.Global
        // (%refly.check (%spirv.loadable class, class, "storage class not loadable"))
        class
        decs T]
    → [%mem.M 0, T];

axm %spirv.storable: %spirv.storage.Class → Bool, normalize_storable;
axm %spirv.store: {class: %spirv.storage.Class}
    → {n: Nat, decs: «n; %spirv.Decoration»}
    → {T: ★}
    → [%mem.M 0, %spirv.Global
        // (%refly.check (%spirv.storable class, class, "storage class not storable"))
        class
        decs T, T]
    → [%mem.M 0];

/// ## Builtins
///
let %spirv.fragment.frag_coord
    = %spirv.Input (%spirv.decor.builtin %spirv.model.Fragment "FragCoord") «2; %math.F32»;

let %spirv.vertex.vertex_index
    = %spirv.Input  (%spirv.decor.builtin %spirv.model.Vertex "VertexIndex"  ) (Idx 3);
let %spirv.vertex.instance_index
    = %spirv.Input  (%spirv.decor.builtin %spirv.model.Vertex "InstanceIndex") Nat;
let %spirv.vertex.vertex_id
    = %spirv.Input  (%spirv.decor.builtin %spirv.model.Vertex "VertexId"     ) Nat;
let %spirv.vertex.instance_id
    = %spirv.Input  (%spirv.decor.builtin %spirv.model.Vertex "InstanceId"   ) Nat;
let %spirv.vertex.position
    = %spirv.Output (%spirv.decor.builtin %spirv.model.Vertex "Position"     ) «4; %math.F32»;
