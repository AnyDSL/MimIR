/// # The compile Plugin {#compile}
///
/// @see mim::plug::compile
///
/// [TOC]
///
/// This plugin handles the optimization pipeline of the compilation of MimIR programs.
/// This plugin's axioms can register mim::Pass%es and mim::Phase%s.
/// Invoke the optimization pipeline by defining a function `_compile: [] → %%compile.Phase`.
///
/// ## Types
///
/// ### %%compile.Pass / %%compile.Phase
///
/// Types for compilation passes and phases.
///
axm %compile.Pass:  *;
axm %compile.Phase: *;
///
/// ## Utility
///
/// ### %%compile.is_loaded
///
/// Checks whether the given plugin is loaded.
///
axm %compile.is_loaded: {n: Nat} → «n; I8» → Bool, normalize_is_loaded;
///
///
/// ### Phases
///
axm %compile.phase(man): {n: Nat} → Bool → «n; %compile.Phase» → %compile.Phase, normalize_phase;
axm %compile.phase(beta_red):                               [] → %compile.Phase, normalize_phase;
axm %compile.phase(branch_normalize):                       [] → %compile.Phase, normalize_phase;
axm %compile.phase(cleanup):                                [] → %compile.Phase, normalize_phase;
axm %compile.phase(eta_exp):                                [] → %compile.Phase, normalize_phase;
axm %compile.phase(eta_red):                                [] → %compile.Phase, normalize_phase;
axm %compile.phase(null):                                   [] → %compile.Phase, normalize_phase;
axm %compile.phase(from_pass):                   %compile.Pass → %compile.Phase, normalize_phase;
axm %compile.phase(prefix_cleanup):         {n: Nat} → «n; I8» → %compile.Phase, normalize_phase;

let %compile.internal_cleanup_phase = %compile.phase.prefix_cleanup "internal_";
///
/// ### Passes
///
axm %compile.pass(man): {n: Nat} → «n; %compile.Pass» → %compile.Pass, normalize_pass;
axm %compile.pass(beta_red):                       [] → %compile.Pass, normalize_pass;
axm %compile.pass(eta_exp):             %compile.Pass → %compile.Pass, normalize_pass; // expects eta_red
axm %compile.pass(eta_red):                      Bool → %compile.Pass, normalize_pass;
axm %compile.pass(lam_spec):                       [] → %compile.Pass, normalize_pass;
axm %compile.pass(null):                           [] → %compile.Pass, normalize_pass;
axm %compile.pass(ret_wrap):                       [] → %compile.Pass, normalize_pass;
axm %compile.pass(scalarize):           %compile.Pass → %compile.Pass, normalize_pass; // expects eta_exp
axm %compile.pass(tail_rec_elim):       %compile.Pass → %compile.Pass, normalize_pass; // expects eta_red

let optimization_passes = %compile.pass.man (
    %compile.pass.beta_red (),
    let er = %compile.pass.eta_red ff; er,
    let ee = %compile.pass.eta_exp er; ee,
    %compile.pass.scalarize ee,
    %compile.pass.tail_rec_elim er,
);

let optimization_phase = %compile.phase.from_pass optimization_passes;
