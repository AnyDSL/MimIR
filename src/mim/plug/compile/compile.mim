/// # The compile Plugin {#compile}
///
/// @see mim::plug::compile
///
/// [TOC]
///
/// This plugin handles the optimization part of the compilation of Mim programs.
/// Plugins can register passes and phases using the axioms from this plugin.
/// The program then can invoke the optimization pipeline by defining a function `_compile: [] → %%compile.Pipeline`.
///
/// ## Types
///
/// ### %%compile.Pass / %%compile.Phase
///
/// Types for compilation passes and phases.
///
axm %compile.Pass:  *;
axm %compile.Phase: *;
///
/// ## Expressions
///
/// ### %%compile.is_loaded
///
/// Checks whether the given plugin is loaded.
///
axm %compile.is_loaded: {n: Nat} → «n; I8» → Bool, normalize_is_loaded;
///
/// ### %%compile.passes_to_phase
///
/// Sets up `n` passes into the PassMan and wraps it as Phase.
///
axm %compile.passes_to_phase: {n: Nat} → «n; %compile.Pass » → %compile.Phase;
axm %compile.phases_to_phase: {n: Nat} → «n; %compile.Phase» → %compile.Phase;
///
/// ### Phases
///
axm %compile.null_phase:                                %compile.Phase;
axm %compile.cleanup_phase:                             %compile.Phase;
axm %compile.beta_red_phase:                            %compile.Phase;
axm %compile.eta_red_phase:                             %compile.Phase;
axm %compile.eta_exp_phase:                             %compile.Phase;
axm %compile.branch_normalize_phase:                    %compile.Phase;
axm %compile.debug_phase:                         Nat → %compile.Phase;
axm %compile.prefix_cleanup_phase: {n: Nat} → «n; I8» → %compile.Phase;

let %compile.internal_cleanup_phase = %compile.prefix_cleanup_phase "internal_";
///
/// ### Passes
///
axm %compile.beta_red_pass:       %compile.Pass;
axm %compile.eta_red_pass:        %compile.Pass;
axm %compile.eta_exp_pass:        %compile.Pass;
axm %compile.scalarize_pass:      %compile.Pass;
axm %compile.tail_rec_elim_pass:  %compile.Pass;
axm %compile.lam_spec_pass:       %compile.Pass;
axm %compile.ret_wrap_pass:       %compile.Pass;
axm %compile.null_pass:           %compile.Pass;
///
/// ### Pipelines
///
let optimization_passes = (
    %compile.beta_red_pass,
    %compile.eta_red_pass,
    %compile.eta_exp_pass,
    %compile.scalarize_pass,
    %compile.tail_rec_elim_pass,
);

let optimization_phase = %compile.passes_to_phase optimization_passes;

let default_core_phase =
    %compile.phases_to_phase (
        %compile.passes_to_phase %compile.scalarize_pass,
        %compile.passes_to_phase %compile.eta_red_pass,
        %compile.passes_to_phase %compile.tail_rec_elim_pass,
        optimization_phase,
        %compile.internal_cleanup_phase,
        %compile.passes_to_phase %compile.lam_spec_pass,
        %compile.passes_to_phase %compile.ret_wrap_pass,
    );

lam extern _fallback_compile(): %compile.Phase = default_core_phase;
