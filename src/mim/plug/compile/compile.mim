/// # The compile Plugin {#compile}
///
/// @see mim::plug::compile
///
/// [TOC]
///
/// This plugin handles the optimization part of the compilation of Mim programs.
/// Plugins can register passes and phases using the axioms from this plugin.
/// The program then can invoke the optimization pipeline by defining a function `_compile: [] → %%compile.Pipeline`.
///
/// ## Types
///
/// ### %%compile.Pass / %%compile.Phase
///
/// Types for compilation passes and phases.
///
axm %compile.Pass:  *;
axm %compile.Phase: *;
///
/// ### %%compile.Pipeline / %%compile.PassList
///
/// Types for functions that accept an arbitrary number of phases and passes respectively.
///
rec %compile.Pipeline:      □ = %compile.Phase → %compile.Pipeline;
rec %compile.PassList:      □ = %compile.Pass  → %compile.PassList;
rec %compile.CombinedPhase: □ = %compile.Phase → %compile.CombinedPhase;
///
/// @note This is a forward declaration for `opt.mim`.
///
axm %compile.Plugin: *;
///
/// ## Expressions
///
/// ### Registered Plugins
///
/// We expect the name in the tag before the `_` to be the name of the plugin (as given in `%%comiple.name_plugin`).
/// @note This is a forward declaration for `opt.mim`.
///
axm %compile.core_plugin:     %compile.Plugin;
axm %compile.mem_plugin:      %compile.Plugin;
axm %compile.demo_plugin:     %compile.Plugin;
axm %compile.affine_plugin:   %compile.Plugin;
axm %compile.autodiff_plugin: %compile.Plugin;
axm %compile.clos_plugin:     %compile.Plugin;
axm %compile.direct_plugin:   %compile.Plugin;
axm %compile.refly_plugin:    %compile.Plugin;
axm %compile.regex_plugin:    %compile.Plugin;
axm %compile.matrix_plugin:   %compile.Plugin;
///
/// ### %%compile.pipeline
///
/// Given n phases, returns the representation of a pipeline.
///
axm %compile.pipeline: %compile.Pipeline;
///
/// ## Passes and Phases
///
/// ### %%compile.debug_phase
///
/// Given a log level, returns a phase that prints the externals (for log level >= 2).
///
axm %compile.debug_phase: Nat → %compile.Phase;
///
/// ### %%compile.pass_phase
///
/// Given n passes, returns a phase that applies them in order.
///
/// TODO: combine two pass_list
axm %compile.pass_list: %compile.PassList;
/// `pass_phase (pass_list pass1 ... passN) = passes_to_phase N (pass1, ..., passN)`
axm %compile.pass_phase: %compile.PassList → %compile.Phase, normalize_pass_phase;
axm %compile.passes_to_phase: {n: Nat} → «n; %compile.Pass» → %compile.Phase;
/// `combine_pass_list K (pass_list pass11 ... pass1N) ... (pass_list passK1 ... passKM) = pass_list pass11 ... p1N ... passK1 ... passKM`
axm %compile.combine_pass_list: {n: Nat} → «n; %compile.PassList» → %compile.PassList, normalize_combine_pass_list;
/// `single_pass_phase pass = passes_to_phase pass`
// TODO: as let instead of axiom
axm %compile.single_pass_phase: %compile.Pass → %compile.Phase, normalize_single_pass_phase;
///
/// ### %%compile.combined_phase
///
/// Given n phases, returns a phase that applies them in order.
///
axm %compile.phase_list: %compile.CombinedPhase;
/// `combined_phase (phase_list phase1 ... phaseN) = phases_to_phase N (phase1, ..., phaseN)`
axm %compile.combined_phase: %compile.CombinedPhase → %compile.Phase, normalize_combined_phase;
axm %compile.phases_to_phase: {n: Nat} → «n; %compile.Phase» → %compile.Phase;
///
/// ### Phases
///
axm %compile.null_phase:             %compile.Phase;
axm %compile.beta_red_phase:         %compile.Phase;
axm %compile.eta_red_phase:          %compile.Phase;
axm %compile.eta_exp_phase:          %compile.Phase;
axm %compile.branch_normalize_phase: %compile.Phase;
///
/// ### Passes
///
/// Basic passes that are defined in the core of Mim.
///
axm %compile.beta_red_pass:       %compile.Pass;
axm %compile.eta_red_pass:        %compile.Pass;
axm %compile.eta_exp_pass:        %compile.Pass;
axm %compile.scalarize_pass:      %compile.Pass;
axm %compile.tail_rec_elim_pass:  %compile.Pass;
axm %compile.lam_spec_pass:       %compile.Pass;
axm %compile.ret_wrap_pass:       %compile.Pass;
axm %compile.null_pass:           %compile.Pass;

axm %compile.prefix_cleanup_pass: {n: Nat} → «n; I8» → %compile.Pass;

let %compile.internal_cleanup_pass = %compile.prefix_cleanup_pass "internal_";
///
/// ### Pipelines
///
let optimization_pass_list =
    %compile.pass_list
        %compile.beta_red_pass
        %compile.eta_red_pass
        %compile.eta_exp_pass
        (%compile.scalarize_pass)
        (%compile.tail_rec_elim_pass);

let optimization_phase = %compile.pass_phase optimization_pass_list;

let default_core_pipeline =
    %compile.pipeline
        (%compile.single_pass_phase %compile.scalarize_pass)
        (%compile.single_pass_phase %compile.eta_red_pass)
        (%compile.single_pass_phase %compile.tail_rec_elim_pass)
        optimization_phase
        (%compile.single_pass_phase %compile.internal_cleanup_pass)
        (%compile.single_pass_phase %compile.lam_spec_pass)
        (%compile.single_pass_phase %compile.ret_wrap_pass);

lam extern _fallback_compile(): %compile.Pipeline = default_core_pipeline;
///
/// ### Dependent Passes and Phases
///
axm %compile.plugin_select: [T: *] → %compile.Plugin → T → T → T;

let plugin_phase = %compile.plugin_select %compile.Phase;
let plugin_pass  = %compile.plugin_select %compile.Pass;

lam plugin_cond_phase(plug: %compile.Plugin, phase: %compile.Phase): %compile.Phase = plugin_phase plug phase %compile.null_phase;
lam plugin_cond_pass (plug: %compile.Plugin, pass:  %compile.Pass ): %compile.Pass  = plugin_pass  plug pass  %compile.null_pass;
