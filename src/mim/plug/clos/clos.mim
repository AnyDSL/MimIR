/// # The clos Plugin {#clos}
///
/// @see mim::plug::clos
///
/// [TOC]
///
/// ## Dependencies
///
plugin core;
///
/// ## Operations related to longjmp
///
let %clos.BufPtr = %mem.Ptr0 I8;
axm %clos.alloc_jmpbuf: %mem.M → [%mem.M, %clos.BufPtr];
axm %clos.setjmp: [%mem.M, %clos.BufPtr] → [%mem.M, I32];
axm %clos.longjmp: Cn [%mem.M, %clos.BufPtr, I32];
///
/// ## Closure Attribute
///
/// Used internally to classify the use of differen Lambdas.
/// mim::plug::clos::ClosConvPrep places these attributes:
///     * `ret`: returning lambda
///     * `freeBB`: ordinary basic block (see mim::Lam::is_basicblock())
///     * `fstclassBB`: basic block that is passed around
///     * `esc`: lambda that escapes its parent scope
///     * `bot`: no special use
///
axm %clos.attr(returning, freeBB, fstclassBB, esc, bottom): {T: *} → T → T, normalize_clos;
///
/// ## Phases and Passes
///
/// ### Passes
///
axm %clos.pass(clos_conv_prep):        [] → %compile.Pass, normalize_pass;
axm %clos.pass(branch_clos):           [] → %compile.Pass, normalize_pass;
axm %clos.pass(lower_typed_clos_prep): [] → %compile.Pass, normalize_pass;
axm %clos.pass(clos2sjlj):             [] → %compile.Pass, normalize_pass;
///
/// ### Phases
///
axm %clos.phase(clos_conv):        [] → %compile.Phase, normalize_phase;
axm %clos.phase(lower_typed_clos): [] → %compile.Phase, normalize_phase;
///
/// ### Pipelines
///
let clos_opt1_passes =
    %compile.pass.man (
        let er = %compile.pass.eta_red tt; er,
        %compile.pass.eta_exp er,
        %compile.pass.scalarize (%compile.pass.null ()),
    );

let clos_opt2_passes =
    %compile.pass.man (
        %compile.pass.scalarize (%compile.pass.null ()),
        %clos.pass.branch_clos (),
        %mem.pass.copy_prop tt (%compile.pass.null ()) (%compile.pass.null ()),
        %clos.pass.lower_typed_clos_prep (),
        %clos.pass.clos2sjlj (),
    );

let clos_phases =
    %compile.phase.man ff (
        optimization_phase,
        %compile.phase.from_pass (%mem.pass.reshape tt),
        %mem.phase.add_mem (),
        %compile.phase.from_pass (%clos.pass.clos_conv_prep ()),
        %compile.phase.from_pass (%compile.pass.eta_exp (%compile.pass.null ())),
        %clos.phase.clos_conv (),
        %compile.phase.from_pass clos_opt1_passes,
        %compile.phase.from_pass clos_opt2_passes,
        %clos.phase.lower_typed_clos (),
    );
