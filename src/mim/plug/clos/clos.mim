/// # The clos Plugin {#clos}
///
/// @see mim::plug::clos
///
/// [TOC]
///
/// ## Dependencies
///
plugin core;
///
/// ## Operations related to longjmp
///
let %clos.BufPtr = %mem.Ptr0 I8;
axm %clos.alloc_jmpbuf: %mem.M → [%mem.M, %clos.BufPtr];
axm %clos.setjmp: [%mem.M, %clos.BufPtr] → [%mem.M, I32];
axm %clos.longjmp: Cn [%mem.M, %clos.BufPtr, I32];
///
/// ## Closure Attribute
///
/// Used internally to classify the use of differen Lambdas.
/// mim::plug::clos::ClosConvPrep places these attributes:
///     * `ret`: returning lambda
///     * `freeBB`: ordinary basic block (see mim::Lam::is_basicblock())
///     * `fstclassBB`: basic block that is passed around
///     * `esc`: lambda that escapes its parent scope
///     * `bot`: no special use
///
axm %clos.attr(returning, freeBB, fstclassBB, esc, bottom): {T: *} → T → T, normalize_clos;
///
/// ## Passes and Phases
///
/// ### Passes
///
axm %clos.clos_conv_prep_pass:        %phase.Pass;
axm %clos.branch_clos_pass:           %phase.Pass;
axm %clos.lower_typed_clos_prep_pass: %phase.Pass;
axm %clos.clos2sjlj_pass:             %phase.Pass;
axm %clos.eta_red_bool_pass:   Bool → %phase.Pass;
///
/// ### Phases
///
axm %clos.clos_conv_phase:        %phase.Phase;
axm %clos.lower_typed_clos_phase: %phase.Phase;

let clos_opt1_passes = (
    %clos.eta_red_bool_pass tt,
    %phase.eta_exp_pass,
    %phase.scalarize_pass,
);

let clos_opt2_passes = (
    %phase.scalarize_pass,
    %clos.branch_clos_pass,
    %mem.copy_prop_pass tt,
    %clos.lower_typed_clos_prep_pass,
    %clos.clos2sjlj_pass,
);

let clos_phases =
    %phase.phases ff (
        optimization_phase,
        %phase.passes (%mem.reshape_pass %mem.reshape_flat),
        %mem.add_mem_phase,
        %phase.passes %clos.clos_conv_prep_pass,
        %phase.passes %phase.eta_exp_pass,
        %clos.clos_conv_phase,
        %phase.passes clos_opt1_passes,
        %phase.passes clos_opt2_passes,
        %clos.lower_typed_clos_phase,
    );
