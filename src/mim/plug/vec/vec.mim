/// # The vec Plugin {#vec}
///
/// @see mim::plug::vec
///
/// Utilitly functions for arrays to behave them like vectors in other languages.
///
/// [TOC]
///
/// ## Dependencies
///
plugin core;
///
/// ## Iterators
///
/// ### %%vec.fold
///
/// [Fold aka Reduction](https://en.wikipedia.org/wiki/Fold_(higher-order_function)) of the vector with `f`:
/// * `%%vec.fold.l f (init, (e1, ..., en))` is `f (... (f (f (init, e1), e2)) ..., en)`.
/// * `%%vec.fold.r f ((e1, ..., en), init)` is `f (e1, f (e2, ... (f (en, init) ...)))`.
///
/// | `%%vec.fold.l`                                                                                 | `%%vec.fold.r`                                                                                   |
/// |------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
/// | ![Left Fold](https://upload.wikimedia.org/wikipedia/commons/5/5a/Left-fold-transformation.png) | ![Right Fold](https://upload.wikimedia.org/wikipedia/commons/3/3e/Right-fold-transformation.png) |
///
axm %vec.fold(l): {A E: *} → {n: Nat} → [f: [A, E] → A] → [init: A, «n; E»] → A, normalize_fold;
axm %vec.fold(r): {A E: *} → {n: Nat} → [f: [E, A] → A] → [«n; E», init: A] → A, normalize_fold;
///
/// ### %%vec.map
///
/// `%%vec.map f (a1, ..., an)` applies function `f` to `a1`, ..., `an`, and builds the vector `(f a1, ..., f an)` with the results returned by `f`.
///
axm %vec.map: {T U: *} → {n: Nat} → [f: T → U] → «n; T» → «n; U», normalize_map;
///
/// ### %%vec.map2
///
/// `%%vec.map2 f (a1, ..., an) (b1, ..., bn)` is `(f (a1, b1), ..., f (an, bn))`.
///
axm %vec.map2: {T U V: *} → {n: Nat} → [f: [T, U] → V] → [«n; T», «n; U»] → «n; V», normalize_map2;
///
/// ### %%vec.map
///
axm %vec.mapn: {ni nv: Nat} → {Ts: «ni; *», U: *} → [f: «i: ni; Ts#i» → U] → «i: ni; «nv; Ts#i»» → «nv; U», normalize_mapn;
///
/// ## Scanning
///
/// ### %%vec.scan
///
/// Does the given predicate hold for all elements/at least one element?
///
axm %vec.scan(for_all, exists): {E: *} → {n: Nat} → [p: E → Bool] → «n; E» → Bool, normalize_scan;
///
/// ### %%vec.unique
///
/// Checks whether all elements in the given vector are distinct from each other (using structural equivalence).
///
axm %vec.is_unique: {T: *} → {n: Nat} → «n; T» → Bool, normalize_is_unique;
///
/// ## Modifiers
///
/// ### %%vec.diff
///
/// Removes elements from vector.
///
axm %vec.diff: {T: *}
             → {n m: Nat}
             → [«n; T», is: «m; Idx n»]
             → «%core.select (%vec.is_unique is, %core.nat.sub (n, m), ⊥:Nat); T», normalize_diff;
