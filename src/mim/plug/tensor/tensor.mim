/// # The tensor Plugin {#tensor}
///
/// @see mim::plug::tensor
///
/// [TOC]
///
/// ## Dependencies
///
plugin tuple;
plugin refly;
plugin vec;
///
/// A tensor plugin
///
/// ## Types
///
/// Represents an [algebraic Ring](https://en.wikipedia.org/wiki/Ring_(mathematics)).
///
let Ring = [
    T: *,
    _0: T,
    _1: T,
    add: [T, T] → T,
    mul: [T, T] → T,
];
///
/// ## Operations
///
/// ### %%tensor.prod_2d
///
/// let nat_ring = (Nat, 0, 1, %core.nat.add, %core.nat.mul);
///
/// ### %%tensor.element_wise
///
axm %tensor.element_wise: {T: *}
                        → {r: Nat, s: «r; Nat»}
                        → {ni: Nat, Is: «ni; *»}
                        → [app: «i: ni; Is#i» → T]
                        → [is: «i: ni; «s; Is#i» »]
                        → «s; T»;
///
/// ### %%tensor.transpose
///
axm %tensor.transpose:  {T: *}
                      → {r: Nat, s: «r; Nat»}
                      → [input: «s;T», permutation: «r;Idx r»]
                      → « <j: r; s#(permutation#j)>; T»;
///
/// ### %%tensor.slice
///
axm %tensor.slice:  {T: *}
                  → {r: Nat, s: «r; Nat»}
                  → [input: «s;T», output_shape: «r; Nat», start_indices: « i:r; Idx (s#i) », steps: « i:r; Nat »]
                  → « output_shape; T»;
///
/// ### %%tensor.reshape
///
axm %tensor.reshape:  {T: *}
                    → {r: Nat, s: «r; Nat»}
                    → [input: «s;T», output_shape: «r; Nat»]
                    → « output_shape; T»;
///
/// ### %%tensor.dot_general
///
/// [Generalized dot product](https://github.com/openxla/stablehlo/blob/main/docs/spec.md#dot_general):
/// * `out_r = nb + (r1 - nc - nb) + (r2 - nc - nb)`
///
axm %tensor.dot_general:  [R: Ring]
                        → {r1 r2: Nat}
                        → {nc nb: Nat}
                        → {s1: «r1; Nat», s2: «r2; Nat»}
                        → [c1: «nc; Idx r1», c2: «nc; Idx r2», b1: «nb; Idx r1», b2: «nb; Idx r2»]
                        → [«s1; R#T», «s2; R#T»]
                        → let bs       = ‹i: nb; %refly.check (%core.ncmp.e ((s1#(b1#i), s2#(b2#i))), s1#(b1#i), "batching dims don't match")›;
                          let n_bc     = %core.nat.add (nb, nc);
                          let bc_1     = %tuple.concat @(nb, nc) @(‹nb; Idx r1>, ‹nc; Idx r1›) (b1, c1);
                          let s1_res   = %vec.diff (s1, bc_1);
                          let n_s1_res = %vec.len s1_res;
                          let bc_2     = %tuple.concat @(nb, nc) @(‹nb; Idx r2›, ‹nc; Idx r2›) (b2, c2);
                          let s2_res   = %vec.diff (s2, bc_2);
                          let n_s2_res = %vec.len s2_res;
                          let s12_res  = %tuple.concat @(n_s1_res, n_s2_res) @(‹n_s1_res; Nat›, ‹n_s2_res; Nat›) (s1_res, s2_res);
                          let s_out    = %tuple.concat @(nb, %vec.len s12_res) @(‹nb; Nat›, ‹%vec.len s12_res; Nat›) (bs, s12_res);
                          «s_out; R#T», normalize_prod;
///
//
/// ### %%tensor.prod_2d
///
/// lam %tensor.prod_2d_lam {R: Ring} {m: Nat, k: Nat, l: Nat} [t1: «m, k; R#T», t2: «k, l; R#T»]
///                 : «m, l; R#T»
///                 = %tensor.dot_general R @(2, 2) @(1, 0) ([0], [1], [], []) (t1, t2);
///
///
/// ### %%tensor.broadcast_in_dim
///
axm %tensor.broadcast_in_dim: {T: *}
                            → {r_in r_out: Nat, s_in: «r_in; Nat», s_out: «r_out; Nat»}
                            → [«s_in; T», «r_in; Idx r_in»]
                            → «s_out; T»;

///
/// ### %%tensor.reduce
///
/// `ni` tensors each of shape `s` and type `Is#i` in arg is
/// * i: ni is a notation for i : (Idx ni)
///
axm %tensor.reduce: {r: Nat, s: «r; Nat»}
                  → {ni: Nat, Is: «ni; *»}
                  → [f: «2; «i: ni; Is#i» » → «i: ni; Is#i»]
                  → [is: «i: ni; «s; Is#i» », init: «i: ni; Is#i», dims: «r; Bool»]
                  → «i: ni; « <j: r; (s#j, 1)#(dims#j)>; Is#i» »;
