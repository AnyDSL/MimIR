def fac_while(n : int) -> int 
{
    if (n == 0) 
        return 1;
    if (n == 1) 
        return 1;

    r : int := 1;
    i : int := 2;
    while (i <= n) {
        r *= i;
        ++i;
    }

    return r;
}

def fac_my_while(n : int) -> int 
{
    if (n == 0) 
        return 1;
    if (n == 1) 
        return 1;

    r : int := 1;
    i : int := 2;

    letrec 
        head := lambda(ir : sigma(int, int), ret : pi(sigma(int, int, bool))) {
            i : int := ir[0];
            r : int := ir[1];
            return #(i, r, i <= n);
        }
        body := lambda(ir : sigma(int, int), ret : pi(sigma(int, int))) {
            i : int := ir[0];
            r : int := ir[1];
            r *= i;
            ++i;
            return #(i, r);
        }
        next := lambda(r) -> noret {
            //...
        }
    in
        my_while(head, body, next);
}

def my_while<L, O>(l : L,
                head : pi(L, pi(sigma(L, bool)), 
                body : pi(L, pi(L)), 
                next : pi(O)) 
{
    h : sigma(L, bool) := head(l);

    if (h[1]) {
        b : L := body(l);
        my_while(b, head, body, next);
    } else {
        next(l);
    }
}

